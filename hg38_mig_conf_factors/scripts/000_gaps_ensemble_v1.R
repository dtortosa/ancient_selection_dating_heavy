##################################################################################
########## SCRIPTS FOR CALCULATING THE ENSEMBLE GAPS INSIDE EACH WINDOW ##########
##################################################################################

#In this script, we calculate the number of nucleotides that correspond to gaps in the ensemble 37. This will be used to remove the gaps from the calculations of the coding density. We do not want to calculate density as the number of coding bases divided by the total length of the window, because inside the window we can have gaps, in which we do not know if the base is coding or not, NA is not the same than zero. If we consider these gaps as zero, we could subestimate the coding density if the the NA data are in reality coding regions. It is better to remove it. 

#ESTOS DATOS NO PUEDE USAR CALCULAR THRESHOLDS A LO LARGO DE LOS CROMOSOMAS. In that case, you need all the gaps in the chromosome, not only those inside the windows. You can only use this data to calculate the real size of each window. 



###################################################
###### CHANGES RESPECT TO PREVIOUS VERSIONS #######
###################################################

#Respect to v1, 
	#the gap length is saved in pair bases instead of kb. 
		#We have to change the final file of gap length. The units are in kb, but this is not useful. The idea of using kb came from the idea of subtracting that length for the window length in kb present in the column name of gene coordinates. However we cannot do that, because some windows are smaller than that as they surpass the limits of the chromosome. Therefore we have to calculate ALWAYS the window length using the window start and end. That coordinates are corrected for the problem of surpassing the length of the chromosome.
		#These coordinates are in pair bases, not in kb!  So each time the gaps length has to be transformed to pair bases to be subtracted from the window length. 
		#Therefore, gap lengths have to be saved in pair bases in the final data set.

#Respect to v2,
	#the windows that surpass the chromosome limit are removed. In the previous version, we trimmed these windows instead.  



##########################################
########## REMOVE PREVIOUS WORKSPACE #####
##########################################
remove(list=ls(all=TRUE))



#################################
###### REQUIRE PACKAGES #########
#################################

require(plyr)#for apply functions across lists and data.frames. This is better than apply, because split rows of a data.frame without converting into matrix or array. In that way you can use "$" to call columns. In addition, you can save the output as a data.frame or a list.
require(GenomicRanges) #for calculating not overlapped genomic ranges



####################################################
####### DESCRIPTION OF TRACK "GAP LOCATIONS" #######
####################################################

#http://genome.ucsc.edu/cgi-bin/hgTrackUi?hgsid=820938253_ZcoN2Y9BnVnPsajnz6fUVIgsT03h&g=gap&hgTracksConfigPage=configure

#See information about genome assembly procedures: https://www.ncbi.nlm.nih.gov/assembly/basics/

	#The Whole Genome Assembly (WGA) approach, which is the dominant strategy in use today, dispenses with up front mapping. The entire genome is fragmented and used to construct libraries of varying insert sizes. Typically there are libraries of some smaller size (2, 4 or 6 Kb), libraries of intermediate size (10 - 40 Kb) and libraries with large insert sequences (>100 Kb). The ends of these clones are sequenced, generating sequence reads. The reads from different ends of the same clone are referred to as mate-pairs.
		#Clones are cloned sequences. For example, BAC/PAC is a Bacterial Artificial Chromosome commonly used cloning vectors for the human genome project. 

	#The original WGS assembly approach, developed using Sanger reads (which are relatively long with low throughput), typically has three major phases, known as overlap, layout, and consensus. In the initial phase (overlap), the WGS algorithm calculates the sequence overlap between all available reads. In the layout step, the reads are arranged according to their pattern of overlap, producing a multiple alignment of the reads. In the consensus step, a contig is generated by calculating the consensus base at each position of the layout. THESE CONTIGS CONTAIN NO GAPS, although the sequence may contain 'N's due to sequence ambiguity (I guess different reads gives a different base for the same position). In other words, a contig is the consensus base at each position from the arrange of reads according to their pattern of overlap. WGS contigs can be submitted to the WGS division of GenBank.

	#After building contigs, a WGS assembler can use mate-pair information to order and orient the contigs and place them into larger structures called scaffolds (or supercontig) (see Figure 3). The contigs within a scaffold are separated by gaps of unknown size, although the library insert sizes can be used to provide good estimates of these gap sizes. The relationship between two contigs can be determined using a single mate-pair, but the level of confidence in such a relationship is not great, and most WGS assemblers require at least two such links for each pair of contigs in a scaffold. Typically, the number of mate-pairs supporting a linkage assertion is not reported, however. These scaffolds can be submitted to the CON (contig) division of GenBank using an AGP file .


#Description if the track:
	#This track depicts gaps in the assembly. These gaps — with the exception of intractable heterochromatic gaps — will be closed during the finishing process.

	#Gaps are represented as black boxes in this track. If the relative order and orientation of the contigs on either side of the gap is known, it is a bridged gap and a white line is drawn through the black box representing the gap.

	#This assembly contains the following principal types of gaps (See details about assemble):

		#Clone — gaps between clones in the same map contig. These may be bridged or not.
			#although a contig has no gaps, it can contain 'N's due to sequence ambiguity (I guess different reads gives a different base for the same position).
		#Contig — non-bridged gaps between map contigs.
			#a contig is the consensus base at each position from the arrange of reads according to their pattern of overlap. 
			#see figure 2 in "https://www.ncbi.nlm.nih.gov/assembly/basics/" for a scheme of a gap between contigs.
		#scaffold - I guess these are gaps between scaffolds (I am guessing, no definition is in the web)
			#WGS assembler can use mate-pair information to order and orient the contigs and place them into larger structures called scaffolds (or supercontig).
		#Centromere — non-bridged gaps from centromeres.
		#Telomere — non-bridged gaps from telomeres.
		#Heterochromatin — non-bridged gaps from large blocks of heterochromatin.
			#Heterochromatin is a tightly packed form of DNA or condensed DNA. 
		#Short Arm — non-bridged long gaps on the short arm of the chromosome.

#Credits
#The Feb. 2009 human reference sequence (GRCh37) was produced by the Genome Reference Consortium.



###############################################
####### SCHEMA OF "GAP - GAP LOCATIONS" #######
###############################################

#From: http://genome.ucsc.edu/cgi-bin/hgTables?db=hg19&hgta_group=map&hgta_track=gap&hgta_table=gap&hgta_doSchema=describe+table+schema

#load the data. Format: This is "Gaps in golden path"
raw_gaps_data = read.table(file="/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/gaps_ensemble/gap.txt", header=FALSE, sep="\t", stringsAsFactors=TRUE)
	#header=FALSE: because the file has not header, the first row already includes data.
	#sep="\t": The file is separated by tabs. I have checked if it works reading it with ";" or "," and it does not. 
	#stringsAsFactors=FALSE: I used this for other data where some variables were like a path. In the case of gap data I think we can set as a factor those variables with strings. We only have one with information about if we know or not the gap (Unknown/known), other with gap type (telomere, clone, etc...) and information about bridge (yes/no).
	#Note: In case would have some problems reading the file ("EOF within quoted string" or "number of items read is not a multiple of the number of columns") you can add 'quote=""' ("https://www.biostars.org/p/170631/"; first response).
str(raw_gaps_data)
head(raw_gaps_data, 10)
nrow(raw_gaps_data)
	#download the file "gap.txt.gz": 
		#"http://hgdownload.soe.ucsc.edu/goldenPath/hg19/database/"
		
	#First 10 rows showed in the scheme. 
		#It has exactly the same values than the 10 first rows showed in the scheme.
		
		#I have checked manually if the first 10 gaps in the chromosome 1 of GRCh37 are these showed in the first 10 rows of the table. They are the ten first gaps in the chromosome.

		#I have checked that these 10 first rows showed in the scheme correspond exactly with gaps in the browser of ensemble. The ensemble browser indicate that these regions are "Golden path gap - no contigs to display". 
			#http://grch37.ensembl.org/Homo_sapiens/Location/View?r=1:1-10000;db=core
			#http://grch37.ensembl.org/Homo_sapiens/Location/View?r=1:177418-227417;db=core
			#http://grch37.ensembl.org/Homo_sapiens/Location/View?r=1:267720-317719;db=core
			#http://grch37.ensembl.org/Homo_sapiens/Location/View?r=1:471369-521368;db=core
			#http://grch37.ensembl.org/Homo_sapiens/Location/View?r=1:2634221-2684220;db=core
			#http://grch37.ensembl.org/Homo_sapiens/Location/View?r=1:3845269-3995268;db=core
			#http://grch37.ensembl.org/Homo_sapiens/Location/View?r=1:13052999-13102998;db=core
			#http://grch37.ensembl.org/Homo_sapiens/Location/View?r=1:13219913-13319912;db=core
			#http://grch37.ensembl.org/Homo_sapiens/Location/View?r=1:13557163-13607162;db=core
			#http://grch37.ensembl.org/Homo_sapiens/Location/View?r=1:17125659-17175658;db=core
	
		#I have also checked in the ucsc genome browser. All the gap variables have the same value than that showed in the scheme. 
			#https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr1%3A1%2D10000&hgsid=821005193_UaQwlATJlbxiWwDdLvWdo4V1uNID
			#https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr1%3A177418%2D227417&hgsid=821005193_UaQwlATJlbxiWwDdLvWdo4V1uNID
			#https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr1%3A267720%2D317719&hgsid=821005193_UaQwlATJlbxiWwDdLvWdo4V1uNID
			#https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr1%3A471369%2D521368&hgsid=821005193_UaQwlATJlbxiWwDdLvWdo4V1uNID
			#https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr1%3A2634221%2D2684220&hgsid=821005193_UaQwlATJlbxiWwDdLvWdo4V1uNID
			#https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr1%3A3845269%2D3995268&hgsid=821005193_UaQwlATJlbxiWwDdLvWdo4V1uNID
			#https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr1%3A13052999%2D13102998&hgsid=821005193_UaQwlATJlbxiWwDdLvWdo4V1uNID
			#https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr1%3A13219913%2D13319912&hgsid=821005193_UaQwlATJlbxiWwDdLvWdo4V1uNID
			#https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr1%3A13557163%2D13607162&hgsid=821005193_UaQwlATJlbxiWwDdLvWdo4V1uNID
			#https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr1%3A17125659%2D17175658&hgsid=821005193_UaQwlATJlbxiWwDdLvWdo4V1uNID

	#database version: 
	#both the scheme and the sql page from the downloaded table ("http://hgdownload.soe.ucsc.edu/goldenPath/hg19/database/gap.sql") indicate that the version is hg19. 
		#sql files:  the MySQL commands used to create the tables

	#Number of rows: The scheme indicated that the table has 497 rows.
	nrow(raw_gaps_data) #exactly 497 rows. 

	#table name: #according to the scheme the primary table is called gap, which is the name of the file downloaded from the golden path. 
	
	#according to the scheme, the last update of the table was: 2020-02-20
	#The sql page for gap indicates a close date (2020-03-22): "http://hgdownload.soe.ucsc.edu/goldenPath/hg19/database/gap.sql"
		#sql files:  the MySQL commands used to create the tables

	#VERY IMPORTANT: The scheme table indicated that it is the hg19 version. The file was downloaded from the hg19 version: "http://hgdownload.soe.ucsc.edu/goldenPath/hg19/database"


##scheme
	#Definitions of each column:
		#bin: Indexing field to speed chromosome range queries.

		#chrom: Reference sequence chromosome or scaffold. 
		unique(raw_gaps_data$V2) #there are other chromosomes rather than the autosomals

		#chromStart
		summary(raw_gaps_data$V3) #start position in chromosome

		#chromEnd
		summary(raw_gaps_data$V4) #end position in chromosome

		#index count of this fragment (obsolete/useless)
		unique(raw_gaps_data$V5) #I do not think that this is the number of the contig, because the second gap is the third, not the fourth segment. 
		
		#'N' for gaps of known size, 'U' for gaps of unknown size
		unique(raw_gaps_data$V6) #there is no unknown size, all cases have "N". 

		#size of gap
		summary(raw_gaps_data$V7)

		#type of gap
		unique(raw_gaps_data$V8) #scaffold, contig, clone, fragment, etc.

		#this is the bridge
		unique(raw_gaps_data$V9) #yes, no, mrna, bacEndPair, etc.

		#all gaps with bridge = "yes" belongs to the type clone or scaffold. 
		unique(raw_gaps_data[which(raw_gaps_data$V9=="yes"),]$V8)

		#all gaps with bridge = "no" belongs to the type telomere, contig, clone, centromere, heterocromatin and short arm. 
		unique(raw_gaps_data[which(raw_gaps_data$V9=="no"),]$V8)
			#Therefore all scaffold are bridged. 



#################################
###### PREPARE THE DATASET ######
#################################

##select only variables of interest
raw_gaps_data_subset = raw_gaps_data[,c(2,3,4,6,7,8,9)] #we are going to use only the chromosome, the start/end, check that the size is known or not, size of the segment, gap type, bridged or not
head(raw_gaps_data_subset)

#set the corresponding names of the columns
colnames(raw_gaps_data_subset) <- c("chrom", "chromStart", "chromEnd", "check_size", "size", "gap_type", "bridged")
str(raw_gaps_data_subset)


##remove chromosomes that are not the typical autosomal and sex chromosomes
#chromosome of interest
selected_chromosomes = paste("chr", 1:22, sep="") #Y has very few genes, thus it is not included. The X will be used for another paper, but we will take the data. As we do not have gene ids for other chromosomes, no other chromosome will be considered when calculating density, because the windows will be calculated around genes of 1:22 and X.

#select those rows whose chromosome name is included in selected_chromosomes
raw_gaps_data_subset = raw_gaps_data_subset[which(raw_gaps_data_subset$chrom %in% selected_chromosomes),]

#check that everything works well
unique(raw_gaps_data_subset$chrom)
!FALSE %in% c(unique(raw_gaps_data_subset$chrom) %in% paste("chr", 1:22, sep=""))
!FALSE %in% c(paste("chr", 1:22, sep="") %in% unique(raw_gaps_data_subset$chrom))
!c("chrY", "chrX") %in% unique(raw_gaps_data_subset$chrom) #we have only the 22 autosomes, while we do not have the Y and X chromosomes. 


##sum 1 to the start because the start begins at zero in bed files (see above)
raw_gaps_data_subset$chromStart_new <- (raw_gaps_data_subset$chromStart) + 1
	#The scheme table says "Note: all start coordinates in our database are 0-based, not 1-based". Indeed, when I did not sum 1 to the start in the ensemble browser, I did not get the indication that it is a golden path. That indication comes summing 1 to the start position showed in the scheme.
#check 
summary(raw_gaps_data_subset$chromStart_new-1 == raw_gaps_data_subset$chromStart)

#remove the previous chromStart variable
raw_gaps_data_subset$chromStart <- NULL

#reorder columns
raw_gaps_data_subset = raw_gaps_data_subset[,c("chrom", "chromStart_new", "chromEnd", "check_size", "size", "gap_type", "bridged")]

#see the new structure
str(raw_gaps_data_subset)
head(raw_gaps_data_subset)

#check that start is always smaller than the end
summary(raw_gaps_data_subset$chromStart_new < raw_gaps_data_subset$chromEnd)

#check that the difference between chromosome start and end plus 1 (i.e., the whole length by the segment) is equal to the variable that correspond to the size
!FALSE %in% c(raw_gaps_data_subset$chromEnd - raw_gaps_data_subset$chromStart_new + 1 == raw_gaps_data_subset$size) #FALSE is not included in the results, thus all is TRUE.


##load coordinate data
gene_coordinates = read.table('/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/gene_number_cds_coords.txt', sep='\t', header=TRUE)
str(gene_coordinates)
head(gene_coordinates)
unique(gene_coordinates$chromosome) #Only autosomal. Y has very few genes. The X could be used for another paper, but for now we are not considering it because we do not have iHS data.

#gene_coordinates selecting only autosomal chromosomes should be the same than raw gene_coordinates, because from the 9th version, gene_coordinates script only considers autosomal chromosomes.
identical(gene_coordinates, gene_coordinates[which(gene_coordinates$chrom %in% 1:22),])

#select only autosomal just in case
gene_coordinates = gene_coordinates[which(gene_coordinates$chrom %in% 1:22),]
!FALSE %in% c(unique(gene_coordinates$chromosome) %in% 1:22)
!FALSE %in% c(1:22 %in% unique(gene_coordinates$chromosome))
!c("X", "Y") %in% unique(gene_coordinates$chromosome) #the sexual chromosomes are not included, only autosomal.

#remove duplicates
gene_coordinates_no_duplicates = gene_coordinates[-which(duplicated(gene_coordinates$gene_id)),]
	#remember we have all exons of each gene, so we have several rows for the same gene. You have the same windows in all the rows of the same gene. 

#check that the remove of duplicates is correct
if(FALSE){ #I have done this check several times and everything is ok, so we will not make it more. It requires to much memory.
	#coordinates_data_row_dupli_test = gene_coordinates[which(gene_coordinates$gene_id == "ENSG00000000457"),] #extract the rows of the first gene, with all the exons to check that the function will work in ddply. We will introduce a data.frame and "gene_id" as variable to split, so we will get a value of each window per gene.
	#write a function to make the check
	check_windows_duplicate = function(coordinates_data_row_dupli_test){

		#extract the gene id of the gene under study
		selected_gene_id = unique(coordinates_data_row_dupli_test$gene_id)

		#check that the number of cases for upper/lower limit in each size is exactly 1, i.e., for all the rows of a given gene, we have the same windows 
		lower_end_window_50kb_identical = length(unique(coordinates_data_row_dupli_test$lower_end_window_50kb)) == 1   
		upper_end_window_50kb_identical = length(unique(coordinates_data_row_dupli_test$upper_end_window_50kb)) == 1   
		lower_end_window_100kb_identical = length(unique(coordinates_data_row_dupli_test$lower_end_window_100kb)) == 1  
		upper_end_window_100kb_identical = length(unique(coordinates_data_row_dupli_test$upper_end_window_100kb)) == 1  
		lower_end_window_200kb_identical = length(unique(coordinates_data_row_dupli_test$lower_end_window_200kb)) == 1  
		upper_end_window_200kb_identical = length(unique(coordinates_data_row_dupli_test$upper_end_window_200kb)) == 1  
		lower_end_window_500kb_identical = length(unique(coordinates_data_row_dupli_test$lower_end_window_500kb)) == 1  
		upper_end_window_500kb_identical = length(unique(coordinates_data_row_dupli_test$upper_end_window_500kb)) == 1  
		lower_end_window_1000kb_identical = length(unique(coordinates_data_row_dupli_test$lower_end_window_1000kb)) == 1 
		upper_end_window_1000kb_identical = length(unique(coordinates_data_row_dupli_test$upper_end_window_1000kb)) == 1 

		#save the gene id and the checks
		results_check_coord_duplicate = cbind.data.frame(selected_gene_id, lower_end_window_50kb_identical, upper_end_window_50kb_identical, lower_end_window_100kb_identical, upper_end_window_100kb_identical, lower_end_window_200kb_identical, upper_end_window_200kb_identical, lower_end_window_500kb_identical, upper_end_window_500kb_identical, lower_end_window_1000kb_identical, upper_end_window_1000kb_identical)

		#return the results
		return(results_check_coord_duplicate)
	}
	#apply the function to gene_coordinates, splitting the data.frame for each gene id (all row of a gene together)
	check_coords_dupli = ddply(.data=gene_coordinates, .variables="gene_id", .fun=check_windows_duplicate, .inform=TRUE, .parallel=FALSE, .paropts=NULL)
		#".inform=TRUE" generates and shows the errors. This increases the computation time, BUT is very useful to detect problems in your analyses.
		#".parallel" to paralelize with foreach. 
		#".paropts" is used to indicate additional arguments in for each, specially interesting for using the .export and .packages arguments to supply them so that all cluster nodes have the correct environment set up for computing. 
			#ADD PACKAGES USED INSIDE THE FUNCTION
	
	#check we have the correct number of rows
	nrow(check_coords_dupli) == length(unique(gene_coordinates$gene_id))
	#check that all cases we have only TRUE, i.e., only 1 upper/lower limit for each window and gene. 
	summary(check_coords_dupli)

	#check the gene ids are correct
	if(!FALSE %in% c(check_coords_dupli$gene_id == check_coords_dupli$selected_gene_id)){ #if all TRUE

		#remove the second column with id
		check_coords_dupli$selected_gene_id <- NULL
	} else {

		#if not we have an error
		stop("ERROR!! We have a problem with the gene id in check_coords_dupli!!!!")
	}
}



#########################################################
###### CALCULATE THE SIZE OF THE GAPS OF EACH GENE ######
#########################################################
#write a function to calculate the gap length inside the windows of all genes.  
#coordinates_data_row = gene_coordinates_no_duplicates[1,] #extract the first row to check the function will work with ddpply. We will do it for each gene id. The dataset used only have one row for each gene, so we do not need to extract all the rows of a given gene. The first row is for the first gene, the second row is for the second gene, and so on. Having one row for gene let us to obtain several outputs for each row (gen) and save them as different rows. So we will have 5 rows for each gene, one for each window. Each row will have its corresponding check
#coordinates_data_row = gene_coordinates_no_duplicates[which(gene_coordinates_no_duplicates$gene_id=="ENSG00000058453"),] #another option to check the function with a gene that have gaps.
#coordinates_data_row = gene_coordinates_no_duplicates[which(gene_coordinates_no_duplicates$gene_id=="ENSG00000186092"),] #gen very close to the start of the chromosome 1. To check that the script goes well with windows without coordinates (removed because of the window surpass the chromosome limit)
gap_calc = function(coordinates_data_row){

	#extract the gene id of the row
	selected_gene_id = coordinates_data_row$gene_id

	#extract the chromosome name of the row. We add chr because this is the notation used in conserved elements data
	selected_chromosome = paste("chr", coordinates_data_row$chromosome_name, sep="")

	#subset conserved elements data for the selected chromosome
	gap_data = raw_gaps_data_subset[which(raw_gaps_data_subset$chrom == selected_chromosome),]

	#extract the opposite subset to make a check
	opposite_gap_data = raw_gaps_data_subset[-which(raw_gaps_data_subset$chrom == selected_chromosome),]

	#make a check. If the chromosome names of the working dataset are exactly the selected_chromosome of the row under study, and selected chromosome is not included in the opposite subset
	if(!FALSE %in% c(gap_data$chrom == selected_chromosome) & !selected_chromosome %in% opposite_gap_data$chrom){

		#everything is ok
		check_1 = TRUE
	} else {

		#problem
		check_1 = FALSE
	}

	#open an empty data frame to save the conserved elements density of each gene and window
	gaps_final = data.frame(selected_gene_id=NA, selected_window=NA, selected_lower_window=NA, selected_upper_window=NA, length_gaps=NA, length_gaps_kb=NA, check_1=NA, check_2=NA, check_2b=NA, check_3=NA, check_4=NA, check_5=NA, check_6=NA)

	#create a vector with the windows sizes
	window_size = c("50", "100", "200", "500", "1000")

	#for each window size
	for(k in 1:length(window_size)){

		#select the [k] window
		selected_window = window_size[k]

		#extract the values of the lower and upper limit of each window for the row under analysis
		selected_lower_window = eval(parse(text=paste("coordinates_data_row$lower_end_window_", selected_window, "kb", sep="")))
		selected_upper_window = eval(parse(text=paste("coordinates_data_row$upper_end_window_", selected_window, "kb", sep=""))) #we have to add as.numeric because if we extract number and name of these vector elements, we cannot compare each one with ALL the starts and ends in the next lines of code

		#we do not have NA in any of the window limits we perform the calculations
		if(!is.na(selected_lower_window) & !is.na(selected_upper_window)){

			##use GenomicRanges to calculate the overlapping between the window and the gaps
			#dummy example
			if(FALSE){
				#select the reference range from 10 to 100 and another range from 200 to 300
				reference_range = IRanges(start=c(10, 200), end=c(100, 300)) #create a IRange object with the start and end of each of the range

				#convert to genomiRange to have the same format than for the tested ranges. The tested ranges has to be reduced to avoid overlapping and we need genomic ranges for that.
				reference_range_gr = GRanges(seqnames=coordinates_data_row$chrom, ranges=reference_range, strand = '*') #sequnames are the names of the chromosome names. This is very important, because if we select as seq names de exons ids, it consider each exon as independent and do not search for overlapping ranges within all exons; ranges are the start and end of each sequence, and are created with the function IRanges. I have checked that when an exon occupy the whole window, if you use exon id as sequence name, the complete length of the range is not calculated, I have to use the chromosome name. The same occurs when you try to get all the ranges without overlapping with disjoin, only are considered the ranges of the same seqname; strand indicate the sense of the sequence. We have the information of the strand in the strand variable, but as I have revised previously, genomic start/end have the same sense independently of the strand. Just in case, i will use *. In any case, I have seen no changes if this modified in the exon data (i have checked the no impact of strand in this exact example for gap length).
					#this explanation is taken from gene_coordinates_v8.r

				#select 5 ranges to be tested
				test_ranges = IRanges(start=c(1, 9, 11, 21, 31, 100, 150, 221), end=c(5, 101, 20, 30, 40, 110, 170, 230)) #create a IRange object with the start and end of each of the exon sequences of the [i] gene

				#convert the IRange file into a genomic range file
				test_ranges_gr = GRanges(seqnames=coordinates_data_row$chrom, ranges=test_ranges, strand = '*') #sequnames are the names of the chromosome names. This is very important, because if we select as seq names de exons ids, it consider each exon as independent and do not search for overlapping ranges within all exons; ranges are the start and end of each sequence, and are created with the function IRanges. I have checked that when an exon occupy the whole window, if you use exon id as sequence name, the complete length of the range is not calculated, I have to use the chromosome name. The same occurs when you try to get all the ranges without overlapping with disjoin, only are considered the ranges of the same seqname; strand indicate the sense of the sequence. We have the information of the strand in the strand variable, but as I have revised previously, genomic start/end have the same sense independently of the strand. Just in case, i will use *. In any case, I have seen no changes if this modified in the exon data (i have checked the no impact of strand in this exact example for gap length).
					#this explanation is taken from gene_coordinates_v8.r

				#calculate the not overlapping ranges
				not_overlapped_test_ranges_gr = disjoin(test_ranges_gr, with.revmap=TRUE) #‘disjoin’ returns an object of the same type as ‘x’ containing disjoint ranges for each distinct (seqname, strand) pairing. Split all the segments to have no overlap. If for example you have 1-10 and 5-7, the first range would be 1-4, then 5-7, and finally 8-10. You have the second range included within the first one. If ‘with.revmap=TRUE’, a metadata column that maps the ouput ranges to the input ranges is added to the returned object. This is basically a map, tells you what initial ranges are included in each of the new non-overlapped range.

				#find what of the tested ranges and are overlapped with the reference range
				hits = findOverlaps(reference_range_gr, not_overlapped_test_ranges_gr)

				#calculate the exact overlap, i.e., the tested regions that are within the reference ranges 
				overlaps <- pintersect(reference_range_gr[queryHits(hits)], not_overlapped_test_ranges_gr[subjectHits(hits)])
					#queryHits extracts the reference ranges that are overlapped with the tested ranges. If the first reference range hits 2 times, you will have 1, 1. Therefore you will be selecting that reference range two times.
					#subjectHits extracts the tested ranges that are overlapped with the reference ranges. For example, the first tested range is not overlapped, so the first integer in the column of subjectHits in hits is 2, not 1. 
					#You associate each reference range with the overlapped tested ranges. That is the input needed for pintersect.
					#the result is for each of the tested ranges overlapped with the reference ranges, the bases not overlapped are removed.
						#obtained form here "https://support.bioconductor.org/p/72656/"

				#now we can calculate the total length of the overlapped regions
				overlaps@ranges
				sum(overlaps@ranges@width)
			}

			#select the reference range as the selected window
			window_range = IRanges(start=selected_lower_window, end=selected_upper_window) #create a IRange object with the start and end of the [k] window


			##check window size is correct
			#this was done in version 2 to check that the window size is correct for those windows that were trimmed because they surpass the chromosome limit. But since version 3, these windows were removed, so no window should need this. In any case, from the window length is substracted a number of bases that should be zero in all cases.
			#load the chromosome length to remove part of the windows if they surpass the limits of the chromosome
			chrom_length_ucsc_hg19 = read.table("/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/gene_coordinates/chrom_length/chrom_length_final_v1.txt", header=TRUE, sep="\t")

			#select the length of the chromosome selected
			end_chromosome = chrom_length_ucsc_hg19[which(chrom_length_ucsc_hg19$chromosome == selected_chromosome),]$length_bp

			#extract the middle point of the selected gene
			middle_point = coordinates_data_row$middle_point

			#calculate the half of the [k] window length, which will be used to calculate both ends around the gene center
			selected_length_half = ((as.numeric(selected_window)*1000)/2) - 0.5
				#we have to substract 0.5 because we have to count the point in the middle. You have to let 0.5 at each side to have 'space' for the middle point. For example, you have the middle of a gene in 20, and we want a window of 10, if you do 20+5 and 20-5 you will get 15 and 25, 25-15+1 gives 11. You need to remove 0.5 at each side of the center to have exactly the window size you want. 20+4.5=24.5 and 20-4.5=15.5; 24.5-15.5+1=10. In addition, length(15.5:24.5)=10
				#we have to multiply by 1000 the window size because it is in kb, and we want it in bases.

			#calculate the end and start position of the [k] window
			lower_end_check_2 = middle_point - selected_length_half
			upper_end_check_2 = middle_point + selected_length_half
					
			#apply floor to follow the exact same approach used in gene_coordinates script
			lower_end_check_2 = floor(lower_end_check_2)
			upper_end_check_2 = floor(upper_end_check_2)

			#open an empty vector to save the number of bases we have to remove in each end of the [k] window
			bases_to_remove = NULL

			#if the lower end of the [k] window is lower than 1 and hence negative
			if(lower_end_check_2 < 1){

				#we have to remove from the window all the bases between 1 and the end of the window
				bases_to_remove = append(bases_to_remove, abs(1 - lower_end_check_2))
			}

			#if the upper end of the [k] window is higher than the end of the chromosome
			if(upper_end_check_2 > end_chromosome){

				#we have to remove all the bases between the end of the window until the end of the chromosome
				bases_to_remove = append(bases_to_remove, abs(upper_end_check_2 - end_chromosome))
			}
			
			#sum all the bases to be removed
			sum_bases_to_remove = sum(bases_to_remove)

			#convert the window size to bases and the subtract the bases to be removed
			selected_window_check_2 = (as.numeric(selected_window)*1000) - sum_bases_to_remove

			#now check that the width of the genomic range object calculated with the window start and end is exactly the same than the window length obtained from the window expected size subtracting the bases that are outside of the chromosome limit. 
			check_2 = window_range@width == selected_window_check_2

			#check that the sum of bases to remove is zero, because not window is trimmed int he new versions of gene coordinates (since version 10). See at the start of this section for further details.
			check_2b = sum_bases_to_remove == 0
			
			#convert to genomic range to have the same format than for the tested ranges. The rested ranges has to be reduced to avoid overlapping and we need genomic ranges for that.
			window_range_gr = GRanges(seqnames=coordinates_data_row$chrom, ranges=window_range, strand = '*') #sequnames are the names of the chromosome names. This is very important, because if we select as seq names de exons ids, it consider each exon as independent and do not search for overlapping ranges within all exons; ranges are the start and end of each sequence, and are created with the function IRanges. I have checked that when an exon occupy the whole window, if you use exon id as sequence name, the complete length of the range is not calculated, I have to use the chromosome name. The same occurs when you try to get all the ranges without overlapping using disjoin, only are considered the ranges of the same seqname; strand indicate the sense of the sequence. We have the information of the strand in the strand variable, but as I have revised previously, genomic start/end have the same sense independently of the strand. Just in case, i will use *. In any case, I have seen no changes if this modified in the exon data (I have checked the no impact of strand in this exact example for gap length).
				#this explanation is taken from gene_coordinates_v8.r

			#select the gap ranges
			gap_ranges = IRanges(start=gap_data$chromStart_new, end=gap_data$chromEnd) #create a IRange object with the start and end of [k] window. 

			#check that the size of each gap inside the IRrange object is the same to the size variable in the gap data
			check_3 = !FALSE %in% c(gap_ranges@width == gap_data$size)

			#convert the IRange file into a genomic range file
			gap_ranges_gr = GRanges(seqnames=coordinates_data_row$chrom, ranges=gap_ranges, strand = '*') #sequnames are the names of the chromosome names. This is very important, because if we select as seq names de exons ids, it consider each exon as independent and do not search for overlapping ranges within all exons; ranges are the start and end of each sequence, and are created with the function IRanges. I have checked that when an exon occupy the whole window, if you use exon id as sequence name, the complete length of the range is not calculated, I have to use the chromosome name. The same occurs when you try to get all the ranges without overlapping using disjoin, only are considered the ranges of the same seqname; strand indicate the sense of the sequence. We have the information of the strand in the strand variable, but as I have revised previously, genomic start/end have the same sense independently of the strand. Just in case, i will use *. In any case, I have seen no changes if this modified in the exon data (I have checked the no impact of strand in this exact example for gap length).
				#this explanation is taken from gene_coordinates_v8.r

			#calculate the not overlapping ranges
			not_overlapped_gap_ranges_gr = disjoin(x=gap_ranges_gr, with.revmap=TRUE) #‘disjoin’ returns an object of the same type as ‘x’ containing disjoint ranges for each distinct (seqname, strand) pairing. Split all the segments to have no overlap. If for example you have 1-10 and 5-7, the first range would be 1-4, then 5-7, and finally 8-10. You have the second range included within the first one. If ‘with.revmap=TRUE’, a metadata column that maps the ouput ranges to the input ranges is added to the returned object. This is basically a map, tells you what initial ranges are included in each new non-overlapped range.

			#check that the disjoined version of the gap ranges (without the revision map) is similar to the initial ranges. If true, that means that we have no overlapping in the gap ranges
			check_4 = identical(gap_ranges_gr, disjoin(gap_ranges_gr))

			#find what of the tested ranges and are overlapped with the reference range
			hits = findOverlaps(window_range_gr, not_overlapped_gap_ranges_gr)

			#calculate the exact overlap, i.e., the gap regions that included within the window. 
			overlaps <- pintersect(window_range_gr[queryHits(hits)], not_overlapped_gap_ranges_gr[subjectHits(hits)])
				#queryHits extracts what of the reference ranges are overlapped with the tested ranges
				#subjectHits extracts what of the tested ranges are overlapped with the reference ranges. For example, the first tested range is not overlapped, so the first integer in the column of subjectHits in hits is 2, not 1. 
				#You associate each reference range with the overlapped tested ranges. That is the input needed for pintersect.
				#the result is for each of the tested ranges overlapped with the reference ranges, the bases not overlapped are removed.
					#obtained form here "https://support.bioconductor.org/p/72656/"

			#if we have overlapped regions
			if(length(overlaps@ranges)>0){

				#calculate its total length
				length_gaps = sum(overlaps@ranges@width)

				#convert to kb
				length_gaps_kb = (length_gaps/1000)

				#check about kb conversion
				check_5 = !FALSE %in% c(round(length_gaps_kb*1000, 3) == round(length_gaps,3)) #round to avoid problems with the decimals.

			
				##check about gap selection
				#select those gaps overlapped with the window using a different approach
				gaps_inside_window = gap_data[which(gap_data$chromStart_new >= selected_lower_window & gap_data$chromStart_new <= selected_upper_window | gap_data$chromEnd >= selected_lower_window & gap_data$chromEnd <= selected_upper_window | gap_data$chromStart_new < selected_lower_window & gap_data$chromEnd > selected_upper_window),]
					#We select all gaps that satisfy the following conditions:
						#Start is equal/higher than the lower limit of the window AND equal/lower than the upper limit. Therefore, it is included between the window.
						#End is equal/higher than the lower limit of the window AND equal/lower than the upper limit. Therefore, it is included between the window.
						#Start is lower than the lower limit AND End higher than the upper limit. Therefore, the whole window is overlapped with the gap.

				#select those gaps that are not completely inside of the window
				#select those gaps whose start occurs before the start of the window
				gaps_inside_window_start_out = which(gaps_inside_window$chromStart_new < selected_lower_window & gaps_inside_window$chromEnd >= selected_lower_window & gaps_inside_window$chromEnd <= selected_upper_window) #we select those gaps whose start occurs before the start of the window but their end is included in the window. In that way, we removed those with start before and end after. Those will be included in gaps_inside_window_start_out.

				#select those gaps whose end occurs after the end of the window
				gaps_inside_window_end_out = which(gaps_inside_window$chromEnd > selected_upper_window & gaps_inside_window$chromStart_new >= selected_lower_window & gaps_inside_window$chromStart_new <= selected_upper_window) #we select those gaps whose end occurs after the end of the window but their start is included in the window. In that way, we removed those with start before and end after. Those will be included in gaps_inside_window_end_out.

				#select those gaps whose start occurs before the start of the window and end occurs after the end of the window
				gaps_inside_window_start_end_out = which(gaps_inside_window$chromStart_new < selected_lower_window & gaps_inside_window$chromEnd > selected_upper_window)

				#if we have gaps with the start before the beginning of the window
				if(length(gaps_inside_window_start_out)>0){
				
					#for those gaps with the start before the window but the end is inside the window, we set the start of the gap at the start of the window, while the end of the gap remains without change, as it is being included in the window.
					gaps_inside_window[gaps_inside_window_start_out,]$chromStart_new <- selected_lower_window
				}

				#if we have gaps with the end after the beginning of the window
				if(length(gaps_inside_window_end_out)>0){
					
					#for those gaps with the end after the window but the start is inside the window, we set the end of the gap at the end of the window, while the start of the gap remains without change, as it is being included in the window.
					gaps_inside_window[gaps_inside_window_end_out,]$chromEnd <- selected_upper_window
				}

				#if we have gaps with the start before the beginning of the window the end after the beginning of the window
				if(length(gaps_inside_window_start_end_out)>0){

					#for those gaps with the start before the window and the end after the window, we set the start of the gap at the start of the window and the end of the gap at the end of the window. As the gap occupy the whole window, all the window is a gap
					gaps_inside_window[gaps_inside_window_start_end_out,]$chromStart_new <- selected_lower_window
					gaps_inside_window[gaps_inside_window_start_end_out,]$chromEnd <- selected_upper_window
				}

				#calculate the not overlapping ranges of gaps inside the window
				#create a IRange object with the start and end of each of the gap within the [k] window
				#require(IRanges)
				gap_ranges_2 = IRanges(start=gaps_inside_window$chromStart_new, end=gaps_inside_window$chromEnd) #we can see the start and end of each gap.
			
				#create a GRanges object with the ranges of all exon sequences of the [i] gene consindering the all the overlapping ranges
				gap_ranges_2_gr = GRanges(seqnames = gaps_inside_window$chrom, ranges = gap_ranges_2, strand = '*') #sequnames are the names of the chromosome names. This is very important, because if we select as seq names de exons ids, it consider each exon as independent and do not search for overlapping ranges within all exons; ranges are the start and end of each sequence, and are created with the function IRanges. I have checked that when an exon occupy the whole window, if you use exon id as sequence name, the complete length of the range is not calculated, I have to use the chromosome name. The same occurs when you try to get all the ranges without overlapping using disjoin, only are considered the ranges of the same seqname; strand indicate the sense of the sequence. We have the information of the strand in the strand variable, but as I have revised previously, genomic start/end have the same sense independently of the strand. Just in case, i will use *. In any case, I have seen no changes if this modified in the exon data (I have checked the no impact of strand in this exact example for gap length).
					#this explanation is taken from gene_coordinates_v8.r

				#calculate the not overlapping ranges
				not_overlapped_gap_ranges_2_gr = disjoin(x=gap_ranges_2_gr, with.revmap=TRUE) #‘disjoin’ returns an object of the same type as ‘x’ containing disjoint ranges for each distinct (seqname, strand) pairing. Split all the segments to have no overlap. If for example you have 1-10 and 5-7, the first range would be 1-4, then 5-7, and finally 8-10. You have the second range included within the first one. If ‘with.revmap=TRUE’, a metadata column that maps the ouput ranges to the input ranges is added to the returned object. This is basically a map, tells you what initial ranges are included in each new non-overlapped range.

				#sum the width of all non-overlapped ranges
				length_gaps_2 = sum(not_overlapped_gap_ranges_2_gr@ranges@width)

				#check that the length of the gap in this approach is the same than in the previous approach using only genomic ranges
				check_6 = (length_gaps == length_gaps_2)
			} else { #if not
				
				#we do not have gaps overlapped with the [k] window
				length_gaps = 0
				length_gaps_kb = 0
				check_5 = NA
				check_6 = NA
			}
		} else { #if not, and hence the selected window has no coordinates (was removed because surpassed the chromosome limits)

				#set everything as NA. Gap length cannot be zero, because there is no window.
				length_gaps = NA
				length_gaps_kb = NA
				check_1 = NA
				check_2 = NA
				check_2b = NA				
				check_3 = NA
				check_4 = NA
				check_5 = NA
				check_6 = NA
		} 

		#save gap length
		gaps_final = rbind.data.frame(gaps_final, cbind.data.frame(selected_gene_id, selected_window, selected_lower_window, selected_upper_window, length_gaps, length_gaps_kb, check_1, check_2, check_2b, check_3, check_4, check_5, check_6))
	}

	#remove the first row with NAs (all entries are NA)
	gaps_final = gaps_final[-which(rowSums(is.na(gaps_final)) == ncol(gaps_final)),] #remove rows for which the sum of entries with NA is the same than the total number of columns, i.e., all entries have a NA.

	#return the final dataset
	return(gaps_final)
}

#apply the function for each row of gene coordinates
final_gap = ddply(.data=gene_coordinates_no_duplicates, .variables="gene_id", .fun=gap_calc, .inform=TRUE, .parallel=FALSE, .paropts=NULL)
	#gene_coordinates_no_duplicates[sample(1:nrow(gene_coordinates_no_duplicates), 1000),] #for running the analyses in a random sample of 1000 genes.

	#".inform=TRUE" generates and shows the errors. This increases the computation time, BUT is very useful to detect problems in your analyses.
	#".parallel" to parallelize with foreach. 
	#".paropts" is used to indicate additional arguments in for each, specially interesting for using the .export and .packages arguments to supply them so that all cluster nodes have the correct environment set up for computing. 
		#ADD PACKAGES USED INSIDE THE FUNCTION

	#NOTE: ddply reorder the output rows in basis on the variable used to split ("gene_id"), so the first gene id is the lowest number, which correspond with a gene of the chromosome X (ENSG00000000003). It should not be a problem, because we have the exact ID in each row, so the different datasets can be merged. When we will have to remove X genes, we have to select the gene_id of the autosomal chromosomes. 
		#I could use gene_id and chromosome_name as variables to split in ddply. In that way, I would get the rows ordered by chromosome name, and additional column with the chromosome name. I did not know this at the beginning, so I will let it in the way it is because it is not problematic. 

#check the gene ids are correct
if(!FALSE %in% c(final_gap$gene_id == final_gap$selected_gene_id)){ #if all TRUE

	#remove the second column with id
	final_gap$selected_gene_id <- NULL
} else {

	#if not we have an error
	stop("ERROR!! We have a problem with the gene id in final_gap!!!!")
}

#check we have all the genes
nrow(final_gap) == length(unique(gene_coordinates$gene_id))*5 #5 is the number of windows, for each gene we have 5 windows, so the number of rows should five times the number of genes

#take a look to the checks
summary(final_gap)
	#IMPORTANT. The check_2 had FALSE, but NOT Now. Some windows have no exact the same length that the corresponding range calculated with GRanges. I have seen that several cases are those with negative coordinates, i.e., windows of genes close to the start of the chromosome. The window can reach the zero (start chromosome) and beyond leading to negative values. I have changed this in gene coordinates and the problem got solved. 

#check specifically the check 4. This checks that there is no overlapped ranges inside the gap data
summary(final_gap$check_4) #we can have NAs because of the windows that were removed. See below.

#check that the gap length in kb was correctly calculated
!FALSE %in% c(final_gap$length_gaps_kb == (final_gap$length_gaps/1000)) #you have NAs from the Windows removed (see below), but no FALSE is present. When length_gaps_kb was calculate, was done correctly.

#check that the gap length is not higher than the corresponding window
real_window_length = final_gap$selected_upper_window - final_gap$selected_lower_window + 1 #calculate the real window length used in the analyses. This is different that selected window. Selected window was the original window size, but in some cases windows surpass the limits of the chromosome, so we have to cut these windows. The final length can be obtained by subtracting the lower end position from the upper end plus 1 (to have both extremes included -> 10-5+1=6, length(5:10)=6.
!FALSE %in% c(final_gap$length_gaps < real_window_length) #we have FALSES. The NAs come from the cases of windows removed (see below), but FALSES are problematic!

#there are three cases with gaps equal or higher than the size of the window.
subset_with_error = final_gap[which(final_gap$length_gaps >= real_window_length),] #subset them
#these cases have a real window length equal to the gap length
(subset_with_error$selected_upper_window - subset_with_error$selected_lower_window + 1) == subset_with_error$length_gaps

#these are very long genes, whose middle point is within a gap.
gene_coordinates_no_duplicates[which(gene_coordinates_no_duplicates$gene_id=="ENSG00000148357"),]$middle_point
gene_coordinates_no_duplicates[which(gene_coordinates_no_duplicates$gene_id=="ENSG00000168280"),]$middle_point
gene_coordinates_no_duplicates[which(gene_coordinates_no_duplicates$gene_id=="ENSG00000185974"),]$middle_point
	#HMCN2 (ENSG00000148357) gene has a transcript very far away from the rest (show figure 27), thus the middle is very distant from all transcript. Oddly, that middle region is within a gap of data, thus when you calculate the 50kb window you get a only gap.

	#The other two genes (KIF5C [ENSG00000168280] and GRK1 [ENSG00000185974]) with the 50kb window equal to a gap (figure 28 and 29) have a different situation. There is a very very large transcript, with a very long noncoding region in the middle. The middle of the gene is there but also gap.

	#I have asked David about this.  


##NAs caused by removed windows
#we have removed some windows in gene coordinates because these windows surpassed the chromosome limits. 

#check that the windows with NA for one end have NA for the other end of the chromosome. 
summary(final_gap[which(is.na(final_gap$selected_lower_window)),]$selected_window == final_gap[which(is.na(final_gap$selected_upper_window)),]$selected_window)

#check the number of cases with NA in the lower coordinate of the windows are the same than the total number of windows removed in gene_coordinates
number_windows_removed = length(which(is.na(gene_coordinates_no_duplicates$lower_end_window_50kb))) + length(which(is.na(gene_coordinates_no_duplicates$lower_end_window_100kb))) + length(which(is.na(gene_coordinates_no_duplicates$lower_end_window_200kb))) + length(which(is.na(gene_coordinates_no_duplicates$lower_end_window_500kb))) + length(which(is.na(gene_coordinates_no_duplicates$lower_end_window_1000kb))) #we only use lower window, because I checked in the 10 version of gene coordinate that if one coordinate is NA, the coordinate of the other extreme is also NA
number_windows_removed == length(which(is.na(final_gap$selected_lower_window))) #the lower and the upper windows are coordinated in final_gap, if one is NA the other is also NA (see the check above).
	#TRUE

#check that the windows for which the lower coordinate is NA are equal to those with NA for the checks. We only compare with lower window coordinate because in the previous check we checked that both upper and lower coordinates are the same
summary(final_gap[which(is.na(final_gap$selected_lower_window)),]$selected_window == final_gap[which(is.na(final_gap$check_1)),]$selected_window)
summary(final_gap[which(is.na(final_gap$selected_lower_window)),]$selected_window == final_gap[which(is.na(final_gap$check_2)),]$selected_window)
summary(final_gap[which(is.na(final_gap$selected_lower_window)),]$selected_window == final_gap[which(is.na(final_gap$check_2b)),]$selected_window)
summary(final_gap[which(is.na(final_gap$selected_lower_window)),]$selected_window == final_gap[which(is.na(final_gap$check_3)),]$selected_window)
summary(final_gap[which(is.na(final_gap$selected_lower_window)),]$selected_window == final_gap[which(is.na(final_gap$check_4)),]$selected_window)
summary(final_gap[which(is.na(final_gap$selected_lower_window)),]$selected_window == final_gap[which(is.na(final_gap$check_5)),]$selected_window)
summary(final_gap[which(is.na(final_gap$selected_lower_window)),]$selected_window == final_gap[which(is.na(final_gap$check_6)),]$selected_window) #In the last two checks (check_5 and check_6), we can have NAs caused for other reasons different to NAs in the window coordinates. When no gap is included in the window, these two checks are NA. 
summary(final_gap[which(is.na(final_gap$selected_lower_window)),]$selected_window == final_gap[which(is.na(final_gap$length_gaps)),]$selected_window)
summary(final_gap[which(is.na(final_gap$selected_lower_window)),]$selected_window == final_gap[which(is.na(final_gap$length_gaps_kb)),]$selected_window)

#save the data
write.table(final_gap, '/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/gap_length_raw_v3.txt', sep='\t', row.names=FALSE, col.names=TRUE)



####################################################################################################
###### OBTAIN A DATA.FRAME WITH ONE ROW PER GENE AND ONE COLUMN FOR GAP LENGTH OF EACH WINDOW ######
####################################################################################################

#write a function to extract the gap length for each window
#final_gap_row = final_gap[which(final_gap$gene_id == "ENSG00000000457"),] #extract the rows of the first gene, with all the window lengths to check that the function will work in ddply. We will introduce a dataframe and "gene_id" as variable to split, so we will get a value of each window per gene.
extract_gap = function(final_gap_row){

	#extract the selected gene id
	selected_gene_id = unique(final_gap_row$gene_id)

	#for the element of the list under study, extract the conserved element value for each window, from 50 to 1000kb
	length_gaps_50kb = final_gap_row[which(final_gap_row$selected_window == 50),]$length_gaps
	length_gaps_100kb = final_gap_row[which(final_gap_row$selected_window == 100),]$length_gaps
	length_gaps_200kb = final_gap_row[which(final_gap_row$selected_window == 200),]$length_gaps
	length_gaps_500kb = final_gap_row[which(final_gap_row$selected_window == 500),]$length_gaps
	length_gaps_1000kb = final_gap_row[which(final_gap_row$selected_window == 1000),]$length_gaps
		#We have to change the final file of gap length. The units are in kb, but this is not useful. The idea of using kb came from the idea of subtracting that length for the window length in kb present in the column name of gene coordinates. However we cannot do that, because some windows are smaller than that as they suprass the limits of the chromosome. Therefore we have to calculate ALWAYS the window length has to be calculated using the window start and end. That coordinates are corrected for the problem of surpassing the length of the chromosome.
		#These coordinates are in pair bases, not in kb!  So each time the gaps length has to be transformed to pair bases to be subtracted from the window length. 
		#Therefore, gap lengths has to be saved in pair bases in the final data set.


	#return all conserved values values
	return(cbind.data.frame(selected_gene_id, length_gaps_50kb, length_gaps_100kb, length_gaps_200kb, length_gaps_500kb, length_gaps_1000kb))
}

#we will use ddply because you can use a data.frame as an input and save it as an data.frame
gap_results_extracted_final = ddply(.data=final_gap, .variables="gene_id", .fun=extract_gap, .inform=TRUE, .parallel=FALSE, .paropts=NULL) 
	#".inform=TRUE" generates and shows the errors. This increases the computation time, BUT is very useful to detect problems in your analyses.
	#".parallel" to paralelize with foreach. 
	#".paropts" is used to indicate additional arguments in for each, specially interesting for using the .export and .packages arguments to supply them so that all cluster nodes have the correct environment set up for computing. 
		#ADD PACKAGES USED INSIDE THE FUNCTION

#check the gene ids are correct
if(!FALSE %in% c(gap_results_extracted_final$gene_id == gap_results_extracted_final$selected_gene_id)){ #if all TRUE

	#remove the second column with id
	gap_results_extracted_final$selected_gene_id <- NULL
} else {

	#if not we have an error
	stop("ERROR!! We have a problem with the gene id in gap_results_extracted_final!!!!")
}

#check we have all the genes
nrow(gap_results_extracted_final) == length(unique(gene_coordinates$gene_id))

#make checks for the extraction for each window with 50, 100, 200, 500, 10000. We have NAs because of the removed windows. 
#50
summary(final_gap[which(final_gap$selected_window == 50),]$length_gaps == gap_results_extracted_final$length_gaps_50kb)
length(which(is.na(gene_coordinates_no_duplicates$lower_end_window_50kb))) #1 should be the number of NAs
#100
summary(final_gap[which(final_gap$selected_window == 100),]$length_gaps == gap_results_extracted_final$length_gaps_100kb)
length(which(is.na(gene_coordinates_no_duplicates$lower_end_window_100kb))) #6 should be the number of NAs
#200
summary(final_gap[which(final_gap$selected_window == 200),]$length_gaps == gap_results_extracted_final$length_gaps_200kb)
length(which(is.na(gene_coordinates_no_duplicates$lower_end_window_200kb))) #22 should be the number of NAs
#500
summary(final_gap[which(final_gap$selected_window == 500),]$length_gaps == gap_results_extracted_final$length_gaps_500kb)
length(which(is.na(gene_coordinates_no_duplicates$lower_end_window_500kb))) #121 should be the number of NAs
#1000
summary(final_gap[which(final_gap$selected_window == 1000),]$length_gaps == gap_results_extracted_final$length_gaps_1000kb)
length(which(is.na(gene_coordinates_no_duplicates$lower_end_window_1000kb))) #293 should be the number of NAs

#save the data
write.table(gap_results_extracted_final, '/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/gap_length_final_v3.txt', sep='\t', row.names=FALSE, col.names=TRUE)

#save the workspace
save.image("/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/rdata/gap_length_v3.RData")
require(plyr)
require(GenomicRanges)
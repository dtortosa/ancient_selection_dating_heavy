#####################################################################################################################################
################################### SCRIPT FOR OBTAINING GENE COORDINATES & CODING DENSITY ##########################################
#####################################################################################################################################

#From this script we will get the center of each coding gene along with the following confounding factors: Gene length and coding density. This gene center will be used in other scripts to get the data about different confounding genomic factors within different windows that begin in the center of each coding gene.



###################################################
###### CHANGES RESPECT TO PREVIOUS VERSIONS #######
###################################################

##CHANGES RESPECT TO test_biomat.r
	#According to David, I have to use GRCh37 instead of GRCh38, becuase GRCh37 is what he said to you, hg19. Here ('https://www.ncbi.nlm.nih.gov/assembly/GCF_000001405.13/') you can see that hg19 is the synonimum of GRCh37. This assembly is different from GRCh38 ('https://www.ncbi.nlm.nih.gov/assembly/GCF_000001405.39'). 

	#The Genome Reference Consortium Human Build 37, also known as hg19, was released 2/27/2009. The name comes from the institution that generated this assemble. For examples, there is a previous assemble called NCBI36, aka hg18, which was generated by the International Human Genome Sequencing Consortium. After that, 13 patch releases were generated, finishing with GRCh37.13 at 06/28/2013. The next version was a new assemble, GRCh38, released at 12/17/2013, and since then 13 patch released have been generated. The last one at 2/28/2019.
		#You can see this in 'https://www.ncbi.nlm.nih.gov/assembly/organism/9606/all/'

	#the GRCh38 have solved some errors present in the GRCh37 and include new data, like centromere sequences
		#https://bitesizebio.com/38335/get-to-know-your-reference-genome-grch37-vs-grch38/

	#I understood that it is easier to move from a newer version to an older. In addition, it is possible that we don´t have data for confounding factors for the current version (GRCh38). So we will use GRCh37.

	#I have removed the code for exteracting positions of the chromosme 1, it is the same code than for the whole genome. If you want to take a look see test_biomat.r.

	#I have removed the begining with the tutorial following biomart webpage. If you need it, see the test_biomat.r.

## CHANGES RESPECT TO gene_coordinates_v2.r
#In the last version, for each gene name, you will obtain the middle position using start and end pos of the gene. In this version we will obtain the exons of each gene and calculate with theisr positions the total distance of the gene.

## CHANGES RESPECT TO gene_coordinates_v3.r
#A finished the third version after a meeting with David (12/10/2019) where I got the final filters for select gene coordinates and calculate coding density. In the fourth version I will apply these comments and suggestions of David to get the gene coordinates, gene length and coding density.

## CHANGES RESPECT TO gene_coordinates_v4.r
#In this script I have worked into the function to create obtain gene coordinates, gene length and coding densityi for all human genes
#In addition, I have set the working environment properly, setting an adequate number of digits that are shown in the terminal (we have very long numbers with the genetic coordinates)

##CHANGES RESPECT TO genes_coordinates_v5.r
#We will extract coding density within windows of different size using the center of gene as window center. We will take all the exons inside a window of a given width. The length will be the length of the window instead of gene length. The middle of the windows will be the midle of each gene. We will use the window lengths that David told us.

#We will use genomic coding start and end, instrad of the previous way of selecting exons. In the previous verison I found that my both matches perfectly for ALL genes with genomic start/end. For me it is validated the genomic start/end.

##CHANGES RESPECT TO genes_coordinates_v6.r
#I have removed the check_coding_v3, in which we checl if each sequence formed by the start and end of the coding region of eahc gene is overlapped with each window. I did this using apply, which is faster than a loop, but still, it is too slow. I could spend 6 days in running all the analyses for that check. I have though about other checks but I did get any good idea
#I have also removed check_gene_number_v4 becuase the check is slow too. It is faster than the coding checkm but too slow.

##CHANGES RESPECT TO genes_coordinates_v7b.r
#the ckheck to checl that the ranges of coding density are not overlapped, is not done, to slow even with apply.
#I have written another check a lot of faster. Now we can be sure that the rhages for coding density are not overlapped

##CHANGES RESPECT TO genes_coordinates_v8.r
	#Remove the chromosome X because David has not calculated the iHS value for that and requires a lot of work. So we will remove it for now. Maybe in the future we can do a project for that chromosome. 

	#obtain the chromosome length from different sources, compare them and save that coming from the ucsc

	#in case a window overpass the limits of the chromosomes (start or end), the window is stopped in these limits.

	#in the calculation of coding density, 
		
		#we add a check by calculating the total length of coding bases in a different way and comparing it with out initial approach

		#we remove the gap length from the total window length. 

##CHANGES RESPECT TO genes_coordinates_v9.r
	#windows that surpass the limits of the chromosome will be removed, not trimmed. If you trim the windows, you can have a 50kb and 100kb finishing at the same point and hence having a similar width. We do not want. We will remove those that surpass the chromosome limits. We will have a little bit less bigger windows, but it should not be a problem. I think this only affects around 400 genes.



######################
###### LIBRARY #######
######################

#require package
library(biomaRt) #for connecting with ensemble
library(GenomicRanges) #for calculating overlap between exons of a gene
require(stringr) #for replacing "," in the total chromosome length
require(D3GB) #for loading the chromosome length



###########################################
###### SET THE ENVIRONMENT PROPERLY #######
###########################################

#This is indicated in my .Rprofile, but just in case yo forgot it, I have pasted here.

#Always remove previous workspace
rm(list=ls())

#load colorout package to have colorful outputs in the R console
require(colorout)

#load SistWrapper package. In that we can use the function wideScreen to change$
require(SistWrapper)

#For this script we want to see more than 8 digits in the terminal. 8 is the default, so for example, if you make the following division: (45959538+45965751)/2. You will get 45962644, instead of 45962644.5, which is the correct solution. This is caused becasue 45962644.5 has more than 8 numbers, so the last one it is not shown. This does not mean that the calculation is wrong, the correct calculus is made (you can check it with print(x, digits=8 or 9)), but you don´t see the complete solution in the terminal. Because of this, for this work with long numbers (genetic coordinates) we will set the a higher number of digits that are shown
options(digits = 15)



##################################################################################
###### SEARCH AND SELECTION OF THE MART AND DATABASE (SPECIES AND VERSION) #######
##################################################################################

#before run the final analyses we check if we have something in the cache.
	#To save time and computing resources biomaRt will attempt to identify when you are re-running a query you have executed before. Each time a new query is run, the results will be saved to a cache on your computer. If a query is identified as having been run previously, rather than submitting the query to the server, the results will be loaded from the cache. You can get some information on the size and location of the cache using the function biomartCacheInfo():
biomartCacheInfo()

#The cache can be deleted using the command biomartCacheClear(). This will remove all cached files.
#biomartCacheClear()
#biomartCacheInfo()

#look for the list of marts currently included. Everything is version 98.
listMarts()

#connect with the BioMart database we are interested. In this case, ensemble genes
ensembl = useMart(biomart="ENSEMBL_MART_ENSEMBL")

#see the list of datasets included in the database 'ensemble' 
datasets = listDatasets(ensembl) 
head(datasets)

#search for the name of your dataset of interest, which should include 'hsapiens' in its name
searchDatasets(mart = ensembl, pattern = "hsapiens") #the name of the dataset with human data is 'hsapiens_gene_ensembl'

#We are interested in hsapiens_gene_ensembl
datasets[which(datasets$dataset == 'hsapiens_gene_ensembl'),] #the version indicated is GRCh38.p13, but we need GRCh37 (aka hg19), which is the version used by David in previous analyses. Moreover, I think it will be easier to get data of confounding factors according the gene coordinates of this assemble. I think David told me that it is easier to translate data of genomic factors from newer to the older version. For example, we have the new recombination data from deCode in GRCh38, but we can transform it to hg19. I am going to specify the older version GRCh37.

#we want to view the available archived versions. listEnsemblArchives takes no arguments, and produces a table containing the names of the available archived versions, the date they were first available, and the URL where they can be accessed.
listEnsemblArchives() #we select the URL of grch37, aka hg19: http://grch37.ensembl.org

#take a look to the databases in the version of GRCh37 
listMarts(host = 'http://grch37.ensembl.org') #we see ensemble genes, variation and regulation. In all cases release 98, which is the lastest in general (this is not the same than patch release, the last of which is 13 in GRCh37).

#extract the datasets of grch37, aka hg19
grch37_datasets = listDatasets(useMart(host='http://grch37.ensembl.org', biomart='ENSEMBL_MART_ENSEMBL'))

#We are interested in 'hsapiens_gene_ensembl' ()Human genes. 
grch37_datasets[which(grch37_datasets$dataset == 'hsapiens_gene_ensembl'),] #The version indicated is GRCh37.p13, which is the last patch release of GRCh37. It makes sense that 'grch37.ensembl.org' automatically connect with the last patch release of GRC37, but we are going to check it.

#We are going to check that this is the last patch release of GRCh17 of human is 13.
#feb 2014
feb2014_datasets = listDatasets(useMart(host='http://feb2014.archive.ensembl.org', biomart='ENSEMBL_MART_ENSEMBL')) 
feb2014_datasets[which(feb2014_datasets$dataset == 'hsapiens_gene_ensembl'),] #human dataset in feb 2014 is GRCh37.p13

#oct 2014
oct2014_datasets = listDatasets(useMart(host='http://oct2014.archive.ensembl.org', biomart='ENSEMBL_MART_ENSEMBL')) 
oct2014_datasets[which(oct2014_datasets$dataset == 'hsapiens_gene_ensembl'),] #human dataset in oct 2014 (the next release after feb 2014) is GRCh38. In addition, the searcher of ncbi for assemblies give GRCh37.p13 as the last one: 'https://www.ncbi.nlm.nih.gov/assembly/?term=GRCh37'. 
	#I don´t know why, but the dates of versions according to listDatasets are different respect to that shows in ncbi. BUT, we have enough evidence to consider GRCh37.p13 as the last one.  

#it is useful to use the specific URL for avoiding changes in the results if you compile the code again in several months and the current version (default) has changed. We select the url of the specific version we are interested, which is the release of feb 2014, last patch release of GRCh37

#We are going to use GCRh37.p13 (release of feb 2014; see above). Select ensemble genes of human datasets and the GRCh37.p13
grch37_human = useMart(host='http://feb2014.archive.ensembl.org', biomart='ENSEMBL_MART_ENSEMBL', dataset='hsapiens_gene_ensembl')
str(grch37_human) #we use 'http://feb2014.archive.ensembl.org' instead of 'http://grch37.ensembl.org' because the latter is very slow. I have even changed the mirror to useast and the problem persists. The former is a lot of faster. 
#check
listDatasets(grch37_human)[26,] #GRCh37.p13

#See the attributes
grch37_human_attributes = listAttributes(grch37_human)

#see for attributes related to exons
searchAttributes(mart = grch37_human, pattern = c("exon"))
	#ensembl_exon_id is the only attribute within the list of feature_page type that is related to exons.
	#exon_chrom_start and exon_chrom_end are attributes for sequences. You have to use getSequence with the id of a gene to get the beinign and end of the exons. For example: getSequence(id="ENSG00000198793",type="ensembl_gene_id", seqType="gene_exon",mart=ensembl). I think that adding the id of a gene in the argument value of getBM will alos work
	#exon_chrom_start  and exon_chrom_end could alos work, but they are attributes for pages type structure.
	#YOU CANNOT ask for atribbute of type 'pages' when you are filtering by a gene and a the same time get info of the exons.., so for most of the exon characteristics (except ensembl_exon_id), you must filter by gene. Previously you will have to get gen id in a different query.

#see for attributes related to coding density length
searchAttributes(mart = grch37_human, pattern = c("cds"))
searchAttributes(mart = grch37_human, pattern = c('genomic'))

#see for attributes related to the sense of the strand
searchAttributes(mart = grch37_human, pattern = c('strand')) #we have attraibutes for the stran in sequences and feature pages

#see for attributes related to entrez
searchAttributes(mart = grch37_human, pattern = c("entrez"))
	#I have not seen infor for the theree attributes related to entrez in too many rows... 

#See what filter we can apply. 
grch37_human_filters = listFilters(grch37_human)

#see for filters related to exons
searchFilters(mart = grch37_human, pattern = c("exon"))
	#Only ensembl_exon_id Exon ID(s)

#see the values of one the filter we will apply, the chromosome name
listFilterValues(mart = grch37_human, filter = "chromosome_name") #we are only interested in 'normal' data within the 1:22 chromosomes

#select those values of chromosome name that begin by 1 or by 2, i.e., the 22 chromosomes
searchFilterValues(mart = grch37_human, filter = "chromosome_name", pattern = '^1|^2') #we will use only chromsome 1:22 removing all the highly variable regions like those related to the MHC. In these regions the chromosome name is not the actual chromosome where the sequence is, but a different notation for example if it is a highly varaible region with several versions included in the esemble
	#We will also include the X to do a small paper aobut X and differences with the rest of the genome. See below.

#extract the ids of ALL human genes. This will be used to split the query of all data into each gene (see below)
all_gene_ids_grch37_human <- getBM(attributes = c("ensembl_gene_id"), mart = grch37_human)



######################################################
###### CALCUALTE THE LENGTH OF EACH CHROMOSOME #######
######################################################

#This will be used to stop the windows that reach the start or end of the chromosomes.

##data from ncbi
#load chromosome length for GRCh37.p13 copied into a txt file from "https://www.ncbi.nlm.nih.gov/grc/human/data?asm=GRCh37.p13"
chrom_length_ncbi_hg19 = read.table("/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/gene_coordinates/chrom_length/chromosome_length_hg19_from_ncbi.txt", sep="\t", header=T) #chromosome lengths are calculated by summing the length of the placed scaffolds and estimated gaps.

#change col names
colnames(chrom_length_ncbi_hg19) <- c("chromosome", "length_bp", "GenBank.accession", "RefSeq.accession")

#see structure
str(chrom_length_ncbi_hg19)

#change the chromosome length from string to numeric
chrom_length_ncbi_hg19$length_bp_string <- chrom_length_ncbi_hg19$length_bp #save the string length as a new variable
chrom_length_ncbi_hg19$length_bp <- NULL #remove the previous one
require(stringr) #load stringr
chrom_length_ncbi_hg19$length_bp = as.numeric(str_replace_all(chrom_length_ncbi_hg19$length_bp_string, ",", "")) #replace the "," by nothing and convert to numeric. If you do not remove the ",", as.numeric() does not work. 

#select only the autosomal chromosomes
chrom_length_ncbi_hg19 = chrom_length_ncbi_hg19[which(chrom_length_ncbi_hg19$chromosome %in% 1:22),]

#check that the order of the chromosomes are ok
!FALSE %in% c(chrom_length_ncbi_hg19$chromosome == 1:22)


##data from uscs
#load chromosome length for GRCh37 as the chromInfo.txt file from "http://hgdownload.soe.ucsc.edu/goldenPath/hg19/database/"
chrom_length_ucsc_hg19 = read.table("/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/gene_coordinates/chrom_length/ucsc_golden_path_hg19/chromInfo.txt", sep="\t", header=F) 
	#the sql page for this file indicates that is hg19: "http://hgdownload.soe.ucsc.edu/goldenPath/hg19/database/chromInfo.sql".
	#info obtained from here "https://support.bioconductor.org/p/14766/"
	
#change colnames 
colnames(chrom_length_ucsc_hg19) <- c("chromosome", "length_bp", "path_not_sure")

#select only autosomal
chrom_length_ucsc_hg19 = chrom_length_ucsc_hg19[which(chrom_length_ucsc_hg19$chromosome %in% paste("chr", 1:22, sep="")),]

#see structure
str(chrom_length_ucsc_hg19)

#reorder the rows to have the chromosome number in increasing order
chrom_length_ucsc_hg19 = chrom_length_ucsc_hg19[match(paste("chr", 1:22, sep=""), chrom_length_ucsc_hg19$chromosome),]

#check rows order
!FALSE %in% c(chrom_length_ucsc_hg19$chromosome == paste("chr", 1:22, sep=""))


##load chromosome length from D3GB
#load the required package
require(D3GB)

#load the chromosome length in GRCh37
chromosome_length_D3GB_hg19 = GRCh37 #Length of human chromosomes based on GRCh37 assembly. See http://www.ncbi.nlm.nih.gov/assembly/GCF_000001405.13/#/st

#change chromosome name
colnames(chromosome_length_D3GB_hg19) <- c("chromosome", "start", "end")

#see structure
str(chromosome_length_D3GB_hg19)

#select only autosomal
chromosome_length_D3GB_hg19 = chromosome_length_D3GB_hg19[which(chromosome_length_D3GB_hg19$chromosome %in% 1:22),]

#see again structure
str(chromosome_length_D3GB_hg19)

#reorder the rows to have the chromosome number in increasing order
chromosome_length_D3GB_hg19 = chromosome_length_D3GB_hg19[match(1:22, chromosome_length_D3GB_hg19$chromosome),]

#check that three sources have the same chromosome length
summary(chrom_length_ncbi_hg19$length_bp - chrom_length_ucsc_hg19$length_bp)
summary(chrom_length_ncbi_hg19$length_bp - chromosome_length_D3GB_hg19$end)
summary(chrom_length_ucsc_hg19$length_bp - chromosome_length_D3GB_hg19$end) #all are the same


##save the chromosome length from ucsc
write.table(chrom_length_ucsc_hg19, "/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/gene_coordinates/chrom_length/chrom_length_final_v1.txt", col.names=TRUE, row.names=FALSE, sep="\t")
	
#I have checked that these lengths matches those of:
	#http://grch37.ensembl.org/Homo_sapiens/Location/Chromosome?r=1%3A1-1000
	
	#"https://www.ncbi.nlm.nih.gov/assembly/GCF_000001405.13/#/st_Primary-Assembly"
		#The chromosome length in ucsc matches that the length of assembled molecules. It does not included the unlocalized scaffolds. 

		#In that page, the ungapped length is smaller than the total length of the Assembled molecule. 
		
		#All of this suggest that gaps and placed scaffolds are included in the length I am using. 



#######################################################################
###### CHECK BEGIN/END GENES REFERS TO REGIONS FLANKED BY EXONS #######
#######################################################################

#check that the beginning and end of genes refers to the beginning and end of the region with exons. You have to bear in mind that by definition, an intron is any nucleotide sequence within a gene that is removed by RNA splicing before translation. The word intro is derived from the them intragenic, i.e., a region inside a gene, thus I guess by definition, an intron must be between exons of a gene. Therefore, I don´t think that the end or start of the gene in ensemble would be an intronic region not flanked by exons of the corresponding gene. You can have non-coding sequences but inside a coding exon, like the 5´ UTR (see figure 11; the 3´ and 5´ below of the line i think that refer to the other strand). Said this, we are going to check it for two genes.

#load the chromosome name, gene id, transcript id, hgnc symbol (gene name), start and end position for genes in chromosome 1. We only use chromosome 1 because it is faster
chr_1_positions <- getBM(attributes=c('chromosome_name', 'ensembl_gene_id', 'hgnc_symbol','start_position','end_position', 'ensembl_transcript_id', 'ensembl_exon_id'), mart = grch37_human, filter='chromosome_name', values='1')
colnames(chr_1_positions)
head(chr_1_positions)
tail(chr_1_positions)
nrow(chr_1_positions)

#SEMA4A
#manual checking with the ensembl browser
chr_1_positions[which(chr_1_positions$ensembl_gene_id =='ENSG00000196189'),]
	#We check that the start (156117157) and end (156147543) correspond to the start and end in the GRCh37.p13 webpage ('http://grch37.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000196189;r=1:156117157-156147543'), and that´s exactly right. The location indicated in the webpage is 'Chromosome 1: 156,117,157-156,147,543' 

	#In figures 3,4 and 6 ('/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego') you can see as the first exon of all transcripts matches the start position and the end position matches the last exon of all transcripts (figure 5).

#extract the structural info (structure characteristics) of the exons included in SEMA4A (ENSG00000196189) to make an additonal check
exons_sema4a = getBM(attributes=c('exon_chrom_start', 'exon_chrom_end', 'is_constitutive','ensembl_exon_id'), mart = grch37_human, filter='ensembl_gene_id', values='ENSG00000196189')

#select the first exon, i.e., smaller pair base of start
start_first_exon_sema4a = exons_sema4a[which(exons_sema4a$exon_chrom_start == min(exons_sema4a$exon_chrom_start)),]$exon_chrom_start

#check that this exon begin just in the start of the gene
start_first_exon_sema4a == unique(chr_1_positions[which(chr_1_positions$ensembl_gene_id =='ENSG00000196189'),]$start_position)

#select the last exon, i.e., bigger pair base of end
end_last_exon_sema4a = exons_sema4a[which(exons_sema4a$exon_chrom_end == max(exons_sema4a$exon_chrom_end)),]$exon_chrom_end

#check that this exon begin just in the start of the gene
end_last_exon_sema4a == unique(chr_1_positions[which(chr_1_positions$ensembl_gene_id =='ENSG00000196189'),]$end_position)

#TMEM183A
#manual checking with the ensembl browser
chr_1_positions[which(chr_1_positions$ensembl_gene_id =='ENSG00000163444'),]
	#We check that the start (202976514) and end (202993976) correspond to the start and end in the GRCh37.p13 webpage ('http://grch37.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000163444;r=1:202976514-202993976'), and that´s exactly right. The location indicated in the webpage is 'Chromosome 1: 202,976,514-202,993,976' 

	#In figures 6, 7 and 8 ('/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego') you can see as the first exon of all transcripts matches the start position and the end position matches the last exon of all transcripts (figure 7,8).

#extract the structural info (structure characteristics) of the exons included in tmem183a (ENSG00000196189) to make an additonal check
exons_tmem183a = getBM(attributes=c('exon_chrom_start', 'exon_chrom_end', 'is_constitutive','ensembl_exon_id'), mart = grch37_human, filter='ensembl_gene_id', values='ENSG00000163444')

#select the first exon, i.e., smaller pair base of start
start_first_exon_tmem183a = exons_tmem183a[which(exons_tmem183a$exon_chrom_start == min(exons_tmem183a$exon_chrom_start)),]$exon_chrom_start

#check that this exon begin just in the start of the gene
start_first_exon_tmem183a == unique(chr_1_positions[which(chr_1_positions$ensembl_gene_id =='ENSG00000163444'),]$start_position)

#select the last exon, i.e., bigger pair base of end
end_last_exon_tmem183a = exons_tmem183a[which(exons_tmem183a$exon_chrom_end == max(exons_tmem183a$exon_chrom_end)),]$exon_chrom_end

#check that this exon begin just in the start of the gene
end_last_exon_tmem183a == unique(chr_1_positions[which(chr_1_positions$ensembl_gene_id =='ENSG00000163444'),]$end_position)

#We can conclude that the variables start and end positions correspond with the begining and end of the exons. However, an exon can included non-coding sequences:

	#I have found that the start/stop position of each exon sum the transcript length, but this length is bigger than the coding sequence length variable. The transcript size includes non-coding sequences like the 5'UTR extreme, BUT NOT introns (Figure 9). I think we should use start and end positions of exons to calculate gene center, but for density of coding sequences, in that case i think the sum of coding sequences if better.
		#David - Coding density. that is very true. You don want to include these sequences when calculating the coding density. You can have an exon, the half of which is translated into a protein, but the other half not (see figure 11; the 3´ and 5´ below of the line i think that refer to the other strand). We can use the attributes CDS length, cds start and cds end of a structure for that.	
		#David - gene length: For gene length does not matter. Even include transcripts that are not translated to functional proteins (decay), because this only move some dozens of bases the gene position, while LD blocks in humans have a length of thousands of pair bases.

	#the transcript density
		#An additional feature could be the length of sequences transcripts divided by gene length. This will be very correlated with coding density, but it would include additional sequences that are not coding like the 5´ UTR. See figure 11 (the 3´ and 5´ below of the line i think that refer to the other strand).
		#We will do the models without this, but then we can added and see if it worth, I guess not... more correlation between predictor...
		#the variable for this would be transcript_length



##############################################
###### LOAD GENE NAMES AND COORDINATES #######
##############################################

#load the chromosome name, gene id, transcript id, hgnc symbol (gene name), start and end position for all genes in ensembl
all_genes_grch37_human <- getBM(attributes=c('chromosome_name', 'ensembl_gene_id', 'ensembl_transcript_id', 'strand', 'ensembl_exon_id', 'hgnc_symbol', 'start_position','end_position'), mart = grch37_human, filters = "ensembl_gene_id", values = all_gene_ids_grch37_human)
	#we apply the gene ids as a filter but setting as value the ids of ALL human genes, which were previously downloaded. I do the download in that way because if you download the whole data is an individual query with a wait limit of 5 minutes. This made the query be stopped. In contrast, if we apply the filter, you will download each gene as an independent query with 5 minutes each one BUT in one file. In addition, we get a bar of progress and an estimated time to the query be finished. See more information and other options for solving this problem here: https://github.com/grimbough/biomaRt/issues/20
colnames(all_genes_grch37_human)
head(all_genes_grch37_human)
tail(all_genes_grch37_human)
nrow(all_genes_grch37_human)
	#I cannot obtain the start and end position of each gene (feature_page characteristics) and at the same time obtain info of each exon (structure or sequences characteristics) because we have to filter by gene for that. We need this information to calculate some confounding factors like the density of coding sequence density, but I think we will need to obtain the list of genes first, and the make a loop for gene calculating the confounding factors we can obtain.

#check differences between total rows and the number of uniques values of ensembl_gene_id
nrow(all_genes_grch37_human) #1314467
length(unique(all_genes_grch37_human$ensembl_gene_id)) #64102 unique gene id.
	#this difference is because for each gene we can have several transcripts, and within each transcript we can have several exons. In addition, note that you can have several gene id for the same hgnc symbol (gene name), I think these are cases with high variability, so different versions of the gene are included, BUT I am not sure. In any case, i think after applying the filter for coding genes, these redundant gene id will be remove.

#remove all the rows that have a chromosome_name different than 1:22. In that way, we remove the exons of genes that are in  mithocondrial DNA or messy sequences like those of the MHC (highly variable regions for which the assemble include several versions, in that cases chromosome name is some like V_MHC...). In addition, we remove the sexual chromosomes. 
	#We don´t take data from the Y because is very small, it has very few genes, so the estimates of the slope of confounding factors only considering this chromosome would have very wide confidence interval (low sample size).
	#We remove X because we do not have iHS for that chromosome right now, and it would entail a great amount of effort to calculate that. In addition, much of the analyses i could do for example with climate would be done within the autosomal only. 
unique(all_genes_grch37_human$chromosome_name)
all_genes_grch37_human_filtered = all_genes_grch37_human[which(all_genes_grch37_human$chromosome_name %in% c(1:22)),]
nrow(all_genes_grch37_human) - nrow(all_genes_grch37_human_filtered)

#check that there is not row with other chromosome_name rather than 1:22
nrow(all_genes_grch37_human_filtered[which(!(all_genes_grch37_human_filtered$chromosome_name %in% c(1:22))),]) == 0 
c(1:22) %in% unique(all_genes_grch37_human_filtered$chromosome_name)
unique(all_genes_grch37_human_filtered$chromosome_name) %in% c(1:22)

#check that each gene name has only one gene id. I can not select those cases without gene name
#extract the gene names without empty cases ('')
gene_names_no_null = unique(all_genes_grch37_human_filtered$hgnc_symbol)
gene_names_no_null = gene_names_no_null[-which(gene_names_no_null == '')]
!'' %in% gene_names_no_null
#for each gene name
test_duplicated_gene_id = data.frame(selected_gene_name=NA, test_result=NA)
for(i in 1:length(gene_names_no_null)){

	#select the [i] gene name
	selected_gene_name = gene_names_no_null[i]

	#extract the unique cases of gene id for the [i] hgnc symbol
	unique_gene_id = unique(all_genes_grch37_human_filtered[which(all_genes_grch37_human_filtered$hgnc_symbol == selected_gene_name),]$ensembl_gene_id)

	#test that the number of unique cases is 1 (only 1 gene id for each gene name)
	test_result = length(unique_gene_id) == 1

	#save
	test_duplicated_gene_id = rbind.data.frame(test_duplicated_gene_id, cbind.data.frame(selected_gene_name, test_result))
}
#remove first row with NAs
test_duplicated_gene_id = test_duplicated_gene_id[-1,]
#take a look for genes with repeated gene id
summary(test_duplicated_gene_id) #we have several cases
#extract information of these genes
genes_with_duplicated_id = test_duplicated_gene_id[which(test_duplicated_gene_id$test_result == FALSE),]$selected_gene_name
all_genes_grch37_human_filtered[which(all_genes_grch37_human_filtered$hgnc_symbol %in% genes_with_duplicated_id),]
	#there are a lot of micro RNA with repeated gene names, but they should be removed after filtering by biotype (check)
	#there is one case of non microRNAs: UGT2A1 has two gene ids, ENSG00000270386 (http://grch37.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000270386;r=4:70454912-70518967;t=ENST00000514019) and ENSG00000173610 (http://grch37.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000173610;r=4:70454135-70518965). It is like ENSG00000270386 is a transcript of ENSG00000270386 that has been separated as an independent gene. They are in the same region, and has the same hgcn symbol. 
		#I do not know what to do with the latter case. Should I removed the gene id with only one transcript, if not we will have the start of two windows in that region. Moreover, I don´t know how detect more cases like this in genes that have no hgcn symbol. 



###################################################################
###### LOAD CODING SEQUENCE LENGTH AND PREPARE CALCULATIONS #######
###################################################################

#we are going to load the positions of all exons of the genome
full_exon_data = getBM(attributes=c('chromosome_name', 'ensembl_gene_id', 'gene_biotype', 'ensembl_transcript_id', 'transcript_biotype', 'strand', 'transcript_start', 'transcript_end', 'ensembl_exon_id', 'exon_chrom_start', 'exon_chrom_end', 'genomic_coding_start', 'genomic_coding_end', 'cds_length', 'cds_start', 'cds_end'), mart = grch37_human, filters = "ensembl_gene_id", values = all_gene_ids_grch37_human)
	#we apply the gene ids as a filter but setting as value the ids of ALL human genes, which were previously downloaded. I do the download in that way because if you download the whole data is an individual query with a wait limit of 5 minutes. This made the query be stopped. In contrast, if we apply the filter, you will download each gene as an independent query with 5 minutes each one BUT in one file. In addition, we get a bar of progress and an estimated time to the query be finished. See more information and other options for solving this problem here: https://github.com/grimbough/biomaRt/issues/20
head(full_exon_data)
	#cds_start and cds_end work fine. For example with ENSG00000196189 (SEMA4A), I have checked the exons in the exon visualizer of the first transcript (ENST00000435124). The first exon is non-coding, so cds start and end is NA. This finishes at 156117221, at 156117222 begins an intron that ends at 156,124,340. At 156,124,341 begins the next exon, first coding (Figure 12). It has as cds start 1, because it is the first one. The first exon have a value of CDS length because it is a global value for the whole gene, but that exon does not contribute to coding length. The same goes for the second transcript (ENST00000414683; figure 13).
	#BUT the most interesting variables are genomic_coding_start and genomic_coding_end. For example, this first transcript of SEMA4A (ENST00000435124) has 139 coding basis in the first coding exon, as cds_start is 1 and cds_end is 139. The range of sequences included between genomic_coding_start and genomic_coding_end (156124508 - 156124370 + 1) is 139. The same goes for the last coding exon, according to the webpage, the coding length here is 153. The range according to genomic coding start and end is also 153 (156131289 - 156131137 + 1), also according to the data of cds_start and end.
		#http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000414683


## check that exons from the whole data and from individual queries are the same

#from full_exon_data extract the data of SEMA4A
sema4a_exon_data_full_query = full_exon_data[which(full_exon_data$ensembl_gene_id == 'ENSG00000196189'),]

#extract exon data of SEMA4A through and individual query
sema4a_exon_data_indv_query = getBM(attributes=c('ensembl_transcript_id', 'transcript_biotype', 'strand', 'transcript_start', 'transcript_end', 'exon_chrom_start', 'exon_chrom_end','ensembl_exon_id', 'genomic_coding_start', 'genomic_coding_end', 'cds_length', 'cds_start', 'cds_end'), mart = grch37_human, filter='ensembl_gene_id', values='ENSG00000196189')

#order rows of the full query according to the exon start position 
sema4a_exon_data_full_query_ordered = sema4a_exon_data_full_query[order(sema4a_exon_data_full_query$exon_chrom_start),]
sort(sema4a_exon_data_full_query_ordered$exon_chrom_start) == sema4a_exon_data_full_query_ordered$exon_chrom_start #check the order is correct

#order rows of the individual query according to the exon start position 
sema4a_exon_data_indv_query_ordered = sema4a_exon_data_indv_query[order(sema4a_exon_data_indv_query$exon_chrom_start),]
sort(sema4a_exon_data_indv_query_ordered$exon_chrom_start) == sema4a_exon_data_indv_query_ordered$exon_chrom_start

#check that the transcript_id, start/end of the exons and the start/end and length of the coding sequence are the same in both queries
identical(sema4a_exon_data_full_query_ordered$ensembl_transcript_id, sema4a_exon_data_indv_query_ordered$ensembl_transcript_id)
identical(sema4a_exon_data_full_query_ordered$exon_chrom_start, sema4a_exon_data_indv_query_ordered$exon_chrom_start)
identical(sema4a_exon_data_full_query_ordered$exon_chrom_end, sema4a_exon_data_indv_query_ordered$exon_chrom_end)
identical(sema4a_exon_data_full_query_ordered$cds_start, sema4a_exon_data_indv_query_ordered$cds_start)
identical(sema4a_exon_data_full_query_ordered$cds_end, sema4a_exon_data_indv_query_ordered$cds_end)
identical(sema4a_exon_data_full_query_ordered$cds_length, sema4a_exon_data_indv_query_ordered$cds_length)
identical(sema4a_exon_data_full_query_ordered$genomic_coding_start, sema4a_exon_data_indv_query_ordered$genomic_coding_start)
identical(sema4a_exon_data_full_query_ordered$genomic_coding_end, sema4a_exon_data_indv_query_ordered$genomic_coding_end)
identical(sema4a_exon_data_full_query_ordered$strand, sema4a_exon_data_indv_query_ordered$strand)

### CHECK ###
##check that the exons obtained from sema4a_exon_data_full_query are the same than those showed in the webpage 
	
	#('http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000435124')
	
	#I have checked that the exons of the first transcript (ENST00000435124) have the same end and start in my data than in the webpage. The introns are not included between exon_chrom_start and exon_chrom_end (Figure 9 in '/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego').

	#I have also checked the size of the transcript and the coding sequence. The length of the transcript is exactly the same than the sum of exon length showed in the webpage:65+168+161+63+99+106+117+125+153 = 1057. BUT the coding sequence length is slightly smaller, 963. I guess that transcript length include UTR extreme and other non-coding sequences. You can see these sequences in the server page.

	#Positions of start and end of exons matches the transcript length, so they included non-coding sequences of the exon, BUT not introns. 
	exons_first_transcript = sema4a_exon_data_full_query[which(sema4a_exon_data_full_query$ensembl_transcript_id == 'ENST00000435124'),] #select data of the first transcript
	exon_sizes_first_transcript = (exons_first_transcript$exon_chrom_end - exons_first_transcript$exon_chrom_start)+1 # calculate the difference between and start of the exons in the first transcript. We sum 1 because we want to include the first and last base. If you calculate the difference between 3 and 5 (5-3), you get 2. 2 consider the middle number (4) and one of the extremes (3 or 5) but not bot of them, and we want the complete distance between 3 and 5 including extremes, so we have to sum 1, 2+1=3. This includes 3, 4, and 5.
	sum(exon_sizes_first_transcript) 
	#sum of the exon sizes of the first transcript is equal to the size of the transcript (1057). This size is bigger than coding sequence length so, both transcript and end/start exon positions included some non-coding sequences as the 5' UTR.
	
	#calculate the length of the whole transcript including introns
	whole_transcript_length = unique(exons_first_transcript$transcript_end) - unique(exons_first_transcript$transcript_start) + 1 

	#calculate the length of introns
	intron_lengths = NULL
	for(i in 1:(nrow(exons_first_transcript)-1)){ #we don´t want the last exon, because the transcript ends there, no more intros after that (only the UTR sequence)

		#calculate the difference between end of the [i] exon and the beginning of the [i+1] exon (i.e., the next one) without including the extremes. Because of this we subtract 1. 2:4 has 3 number including the extremes but only 1 without them (4-2-1=1). This will calculate the introns between each pair of exons. 
		calculated_intron_length = exons_first_transcript[i+1,]$exon_chrom_start - exons_first_transcript[i,]$exon_chrom_end - 1 #the start of the second exon has a higher position than the end of the previous one, because of this the former has to be first.

		#save
		intron_lengths = append(intron_lengths, calculated_intron_length)
	}

	#The whole transcript including introns (but UTR before the first coding exon) should be equal to the sum of the exon sizes plus the sum of intron lengths
	whole_transcript_length == sum(exon_sizes_first_transcript) + sum(intron_lengths)



###########################################################################
### USE OF CDS START AND END TO CALCULATE THE LENGTH OF CODING REGIONS ####
###########################################################################

#cds start and end can be used to calculate when the coding regions start and end. Below you have support for this. HOWEVER, it much easier to use genomic coding start and genomic coding end. These variables give the exact position in which the coding region start and end in each exon. 
sema4a_exon_data_indv_query

	#cds_start seems to indicate the beginning of the coding region in a exon, what it is the coding sequence length at that point. 1 for example would indicate that this is the beginning of the exon. If that exon have a total transcript length of 60, the coding sequences would end at 60. See several examples with
		#The transcript (ENST00000435124) of SEMA4A (ENST00000435124.1; http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000435124; FIGURE 14): 
			#The first exon (ENSE00001737906; 156117157-156117221) has no coding sequence, so cds_start is zero. 
			#The second exon (ENSE00003474176; 156124341-156124508) has the first coding sequence, so cds_start is 1, and the end is 139. The transcript length according to the webpage is 168 and the splice region (removed in splicing and hence not translated; in orange) has 29 bases (I have seen this pasting the exon sequence into libre office, selecting the orange bases, then tools and word count to check the number of characters). 168 - 29 makes 139 which is exactly the value of cds_end.
			#The third exon (ENSE00003510781; 156126205-156126365) has a transcript length of 161 and coding sequences are at the beginning and end of the exon, according the webpage. According to my data, cds_start and end are 140 and 300, which makes 300-140+1=161 (we sum 1 because we want to include both 300 and 140 as they are start and end of coding sequence in this exon), exactly the length of the transcript according to the webpage.
			#the fourth exon (ENSE00003623497; 156127861-156127923) has a transcript length of 161 and coding sequences are at the beginning and end of the exon, according the webpage. It has a transcript length of 63 according to the webpage, and according to my data the cds start and end are 301 and 363, respectively. 363-301+1=63, which is exactly the length of transcripts
			#the fifth exon (ENSE00003487912; 156128179-156128277) it has a transcript length of 99 and the beginning and end of the exon has coding basis according to the webpage. According to my data, the cds start and end is 364 and 462, so the length of the coding sequence is 462-364+1=99, same transcript length.
			#For the last exon occurs the same, 811 and 963 for start and end of coding sequence, which makes 963-811+1=153, which is the transcript length according the webpage. Again, the first and last base is coding in this exon according to the webpage.
		#The transcript (ENST00000368282):
			#The first exon (ENSE00001446766; 156124162-156124508) has as start and end cds 1 and 139, which makes 139-1+1=139 cosing bases. According the webpage, the last 139 bases are coding bases (blue color). 
			#The rest of exons are complete coding except the last one (ENSE00001446765; 156146196-156147543). The start and end coding sequence is 1694 and 2286, respectively. 2286 - 1694 + 1 = 593, which is the exact number of coding basis in the last exon according to the webpage (I have seen this pasting the exon sequence into libre office, selecting the blue bases, then tools and word count to check the number of characters).
			#Again, with start and end cds we can calculate the position of the starting and end coding sequences

	#CDS start = 1 indicates the frist coding exon, without the UTR 5' sequence. The last cds end of the transcript has the same value of the cds length. Therefore we can use cds_start = 1 and cds_end=cds_length to select the data of start and end exon. We can count from the end of the first exon with coding sequence, as many bases as the cds end. For example, cds start and end of the first exon with coding sequence is 1 and 100, the end of that exon is at 110, we should rest 100 from 110 plus 1 to get the range of coding basis. For the end, we should look for the exon whose cds end is equal to cds length. In that exon, we calculate the range of coding baes (cds_end - cds_start) and sum to the exon start. We dont need to rest 1 to the range because the left extreme would be inclued when summing the range to the begining of the exon. For example, 500-400=100, and the exon start at 1000, so 1000 + 100 makes 1100. The right extreme is included in 100 and the left in 1000. 

	#EXAMPLE CDS calculations IN FIGURE 15: In that figure you have the UTR extremes 5' and 3', sveral coding exons, non-coding exons and introns
		#The first exon with coding sequence begins at 2000 pb (A) and ends 3000 pb (C). The cds_start is 1 (C position) and cds_end 501 (B position; remember cds is the length of coding sequence at that point, not the position). We will calculate the position of start of the coding sequence through two differents ways:
			#Method A:
				#[A,C] = C - A + 1 = 3000 - 2000 + 1 = 1001. We calculate the area included between both extremes of the exon, including these extremes. Because of this, we sum 1, to include not only one but the two extremes 
					length(2000:3000) #1001, which is exactly we obtained
					#Note that '[' means extreme included, while '(' means extreme not included. 
				#[A,B) = [A,C] - [B-C] = [A,C] - cds_end = 1001 - 501 = 500. We calculate the distance betwen the begining of the exon and the start of the coding sequence. For that, we substract from the hole length of the exon, the coding region, which has a length of 501 (length(1:501) = 501) and it is called [B,C] or cds_end. As B is included in [B,C], thus B cannot be included in [A,B). 
					1001 - 501 #if the total length of the exon is 1001, and the coding region has 501, the rest of the exon (i.e., non coding exon) would be 500 (501 + x = 1001; 1001-501 = x; x = 500)
				#B = A + [A,B) = 2000 + 500 = 2500. To the begining of the exon, we sum the complete non-coding region to get the begining of the coding region. We don´t have to substract 1, becuase the begining (A) is included in both A and [A,B), but we don´t have the other extreme (B) included in the range ([A,B)), thus we don´t have to substract anything. If we would have sum A + [A,B], then we should substract 1. The result of this operation is exactly B, the begining of the coding region in the first coding exon.
					length(2500:3000) #if the coding region begins at this exon and has a length of 501 pb, and the exon ends at 3000 pb, the region between the estimated begining of the coding region, i.e., 2500, to 3000 should be 501, which is true.

			#Method B:
				#B = C - [B,C] + 1 = 3000 - 501 + 1 = 2500. We substract from the end of the exon the length of the coding sequence ([B,C]; cds_end) but adding 1 to include the begining of the coding region, because the element we are substracting ([B,C]) includes B, so we are removing it from C.
					length(2500:3000) #the result is the same than the method A, and make sense. The sequence begingin at 2500 and finishing at 3000 has a length of 501, which is the cds_end of the first exon.

		#The last exon with coding sequence begins at 4000 pb (D) and ends 5000 pb (F). The cds_start is 1501 (D position) and cds_end is 2001 (E position; remember cds is the length of coding sequence at that point, not the position). We will calculate the position of the end of the coding sequence through two differents ways:
			#Method A:
				#[D,F] = F - D + 1 = 5000 - 4000 + 1 = 1001. We calculate the area included between both extremes of the exon, including these extremes. Because of this, we sum 1, to include not only one but the two extremes 
					length(5000:4000) #1001, which is exactly we obtained
					#Note that '[' means extreme included, while '(' means extreme not included. 
				#[D,E] = cds_end - cds_start + 1 = 2001 - 1501 + 1 = 501. We calculate the length of the coding region calculating the distance between start and end of the coding sequence in this exon, also adding 1 to include both extremes (we want the whole coding sequence). 
					length(1501:2001) #the sequence between 1500 and 2000, which are the cds_start and cds_end, inclduing both extremes should be 501, and this is the case.
				#(E,F] = [D,F] - [D,E] = 1001 - 501 = 500. From the whole length of the exon. we susbtract the length of the coding sequence, obtaining in that way the non coding region of the end, withotu icnluding the E position. 
					1001 - 501 #if the total length of the exon is 1001, and the coding region has 501, the rest of the exon (i.e., non coding exon) would be 500 (501 + x = 1001; 1001-501 = x; x = 500)
				#E = F - (E,F] = 5000 - 500 = 4500. We susbtract from the end of the exon the non-coding region, which does not include the E extreme. This gives the complete coding region until the end. 
					length(4501:5000) #if the coding region end at this exon with a length of 2001, at the beginign of the exon the coding length was 1501 pb, and the exon ends at 5000 pb, the region between 4501 to 5000 should be 500, because the length of the coding squence is 500 (ending at 4500, because of this the sequences begins at 4501)
					length(1501:2001)

			#Method B:
				#E = D + [D,E] -1 = 4000 - 501 - 1 = 4500. We sum to the end of the exon the length of the coding sequence ([D,E]) but susbtracting 1. Note that we begin with 4000, so the begining of the exon is included, [D,E] also includes the begining of the exon becase we summed 1, so we need to remove one to get the exact end of the coding sequence.
					length(4500:5000) #the result is the same than the method A, and make sense. The sequence begingin at 4500 and finishing at 50000 has a length of 501, which is the range between cds_start and cds_end including both extremes.

		#Therefore, the begining position of the coding sequence is 2501 and the ending position es 4500. The range between them (including both extremes) is length(2501:4500) = 2000, which is exactly the cds_length in the example.


### CALCULATION EXAMPLE WITH ENST00000435124 (SEMA4A) ###

	#Coding example with the transcript ENST00000435124 of SEMA4A (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000435124)
	test_data_cds = sema4a_exon_data_indv_query[which(sema4a_exon_data_indv_query$ensembl_transcript_id == 'ENST00000435124'),]
	test_data_cds

	## Calculate the start/end position of the first and last coding exons

	#select the first exon with coding sequence (cds_start == 1)
	first_coding_exon = test_data_cds[which(test_data_cds$cds_start == 1),]
		#The first exon of this transcript is an UTR sequence, then we have an intron and the second exon, which has the first coding sequence. This is the first coding exon -> ENSE00003474176 
		
	#select the last exon with coding sequence (cds_end == to the total cds length) and that it is not the first coding exon. This is made for the cases of genes with only one coding exon. In that way, that unique exon is only considered one time, becuase otherwise the unique exon would satisfy conditions for the first and last coding exon (cds start == 1 and cds end == cds length)
	last_coding_exon = test_data_cds[which(test_data_cds$cds_end == test_data_cds$cds_length & test_data_cds$cds_start != 1),] 
		#This is the last exon, and the last one with coding sequence (ENSE00001655854).

	##calculate the start position of cds with method A
	#total length of the first coding exon
	total_length_first_coding_exon = first_coding_exon$exon_chrom_end - first_coding_exon$exon_chrom_start + 1 #equal to 168, like the transcript length of this exon accoding to ensemnl (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000435124)
	#length of the non coding region in the first coding exon
	noncoding_region_first_coding_exon = total_length_first_coding_exon - first_coding_exon$cds_end
		#29 bases. 29 is exactly the number of non-coding bases in the first coding exon (AGCTCCCTGGTGACAGTCTGTGGCTGAGC) according to the webpage
			#note that the orange bases in the translated sequence (blue) indicate that in that position a SNP exist (different possibilities for that base) leading to a change in the aminoacid codified
	#position of the start codign sequence
	start_cds_position_method_a = first_coding_exon$exon_chrom_start + noncoding_region_first_coding_exon #we are summing A and [A,B), both contains A but not B, so the result will give B and we dont have to sum 1.

	#calculate the start position of cds with method B
	start_cds_position_method_b = first_coding_exon$exon_chrom_end - first_coding_exon$cds_end + 1 #from the end, we substract the whole coding region (including B, the beigining of the coding region), this would lead to the last base of the non-codign region, because of this we sum 1, the get the first base of the coding region.

	#check that both methods match
	start_cds_position_method_a == start_cds_position_method_b

	##calculate the end position of cds with method A
	#total length of the last coding exon
	total_length_last_coding_exon = last_coding_exon$exon_chrom_end - last_coding_exon$exon_chrom_start + 1 #equal to 153, like the transcript length of this exon accoding to ensemnl (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000435124)
	#length of the coding region in the last coding exon
	coding_region_last_coding_exon = last_coding_exon$cds_end - last_coding_exon$cds_start + 1
		#153, which is cogruent the 153 coding bases indicated in the webpage for this exon. The whole exon is coding, so 153 is also the length of the transcript.
	#length of the non-coding region in the last coding exon
	noncoding_region_last_coding_exon = total_length_last_coding_exon - coding_region_last_coding_exon 
	#position of the end coding sequence with method A
	end_cds_position_method_a = last_coding_exon$exon_chrom_end - noncoding_region_last_coding_exon #we are substracting a reange of values (F and (E,F]) that does not include E, thus the result will cinlude E and we do not have to sum 1

	#calculate the start position of cds with method B
	length_coding_sequence_last_coding_exon = last_coding_exon$cds_end - last_coding_exon$cds_start + 1
	end_cds_position_method_b = last_coding_exon$exon_chrom_start + length_coding_sequence_last_coding_exon - 1 #we rest 1 becase the two ranges (D and [D,E]) we are summing both containts D, so we have to substract 1

	#check that both methods match
	end_cds_position_method_a == end_cds_position_method_b


	## Calculate the length of all exons between the first and last coding exon

	#extract the exons between the extremes of the coding region
	exons_between_coding_extremes = test_data_cds[-which(is.na(test_data_cds$cds_start) | test_data_cds$cds_start == 1 | test_data_cds$cds_end == unique(test_data_cds$cds_length)),] #remove those exons that are not coding (cds_start is NA), the first coding exon (cds_start=1) and the last coding exon (cds_end=total length of coding sequence). The remaining exons should be coding exons situated between the first and last coding exons, so they should be complete coding, i.e., no UTR sequence. 

	#extract the position of each exon between the extremes of the coding region
	exon_length_df = data.frame(exon_name=NA, exon_length=NA)
	#for each exon with the extremes
	for(i in 1:nrow(exons_between_coding_extremes)){

		#sleect the [i] exon
		selected_row = exons_between_coding_extremes[i,]

		#calculate the length of the [i] exon
		exon_length = selected_row$exon_chrom_end - selected_row$exon_chrom_start + 1

		#save exon name
		exon_name = selected_row$ensembl_exon_id

		#calculate the length of the [i] exon as end less start adding 1 to include both extremes and save it
		exon_length_df = rbind.data.frame(exon_length_df, cbind.data.frame(exon_name, exon_length))
	}
	#remove the frost row with NAs
	exon_length_df = exon_length_df[-1,]
	exon_length_df
		#the length of each exon correspond with the transcript length of each one in the webpage (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000435124). The 6 exons between the first and last coding exons are entire coding, so transcript and exon length matches (all bases are blue).

	## Calculate total length of coding sequence and check with cds_length from ensemble
	#Sum the length of all exons of the middle plus the length of the coding sequence of the first exon plus the length of the coding sequence of the last coding exon
	length_coding_sequence_first_coding_exon = first_coding_exon$exon_chrom_end - start_cds_position_method_a + 1 #length of the sequence between the end of the first exon and the begining of the coding sequence in that exon. Remember that the coding sequence begins within this exon, so a part of the exon at the begining can be non-coding.
	length_coding_sequence_last_coding_exon = end_cds_position_method_a - last_coding_exon$exon_chrom_start + 1 #length of the sequence between the end of the coding sequence in the last coding exon and the start of that exon. Remember that the coding sequence ends within this exon, so a part of the exon at the end can be non-coding.
	total_cds = sum(exon_length_df$exon_length) + length_coding_sequence_first_coding_exon + length_coding_sequence_last_coding_exon

	#check that matches with cds_length from ensemble
	total_cds == unique(test_data_cds$cds_length)


	## bind the position of each coding sequence

	#bind in one row the following data of the FIRST coding exon: exon id, start position of coding sequence (which can be in the middle of the exon) and the end of that exon (if there are more than 1 coding exon, the coding sequences will continue in other exons)
	first_coding_exon_positions = cbind.data.frame(first_coding_exon$ensembl_exon_id, start_cds_position_method_a, first_coding_exon$exon_chrom_end, first_coding_exon$cds_start, first_coding_exon$cds_end)

	#bind in one row the following data of the coding exons BETWEEN the first and last exons: exon id, the start and end of these exons (the begining of the coding sequence is before and the end is later)
	exons_between_coding_extremes_positions = cbind.data.frame(exons_between_coding_extremes$ensembl_exon_id, exons_between_coding_extremes$exon_chrom_start, exons_between_coding_extremes$exon_chrom_end, exons_between_coding_extremes$cds_start, exons_between_coding_extremes$cds_end)

	#bind in one row the following data of the LAST coding exon: exon id, start position of coding sequence (the begining of the codng sequence began in previous exons) and the end of the coding sequence (which can be in the middle of the exon)	
	last_coding_exon_positions = cbind.data.frame(last_coding_exon$ensembl_exon_id, last_coding_exon$exon_chrom_start, end_cds_position_method_a, last_coding_exon$cds_start, last_coding_exon$cds_end) #first the start position of the coding sequence in the first coding exon, then the start of all coding exons between the first/last coding exons, and finally the start of the last coding exon

	#prepare column names to bind the rows
	colnames(first_coding_exon_positions) <- c('ensembl_exon_id', 'start_position_coding', 'end_position_coding', 'cds_start', 'cds_end')
	colnames(exons_between_coding_extremes_positions) <- c('ensembl_exon_id', 'start_position_coding', 'end_position_coding', 'cds_start', 'cds_end')	
	colnames(last_coding_exon_positions) <- c('ensembl_exon_id', 'start_position_coding', 'end_position_coding', 'cds_start', 'cds_end')

	#bind all the rows into one data frame
	positions_coding_sequences = rbind.data.frame(first_coding_exon_positions, exons_between_coding_extremes_positions, last_coding_exon_positions) #first the end position of the first coding exon, then the end of all coding exons between the first/last coding exons, and finally the end position of the coding sequence in the last coding exon

	##final checks
	#final checks that the sum of the lengths of this start/end positions matches with cds_length from ensemble
	sum(positions_coding_sequences$end_position_coding - positions_coding_sequences$start_position_coding + 1) == unique(test_data_cds$cds_length) #the summatory of the lengths of each sequence (end less start plus 1, i.e., complete range including both extremes) is equal to cds_length form ensemble.

	#final check to test that the length of the coding sequences I have obtained are the same than those of cds start and end position
	positions_coding_sequences$cds_end - positions_coding_sequences$cds_start + 1 == positions_coding_sequences$end_position_coding - positions_coding_sequences$start_position_coding + 1


### CALCULATION EXAMPLE WITH ENST00000414683 (SEMA4A) ###

	#Coding example with the transcript ENST00000414683 of SEMA4A (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000414683)
	test_data_cds_2 = sema4a_exon_data_indv_query[which(sema4a_exon_data_indv_query$ensembl_transcript_id == 'ENST00000414683'),]
	test_data_cds_2 #this transcript has not the exons order based on position in my data, thus it is a good model to test my approach


	## Calculate the start/end position of the first and last coding exons

	#select the first exon with coding sequence (cds_start == 1)
	first_coding_exon_2 = test_data_cds_2[which(test_data_cds_2$cds_start == 1),]
		#The first exon of this transcript is an UTR sequence, then we have an intron and the second exon, which has the first coding sequence. This is the first coding exon -> ENSE00003589564

	#select the last exon with coding sequence (cds_end == to the total cds length) and that it is not the first coding exon. This is made for the cases of genes with only one coding exon. In that way, that unique exon is only considered one time, becuase otherwise the unique exon would satisfy conditions for the first and last coding exon (cds start == 1 and cds end == cds length)
	last_coding_exon_2 = test_data_cds_2[which(test_data_cds_2$cds_end == test_data_cds_2$cds_length & test_data_cds_2$cds_start != 1),] 
		#This is the last exon, and the last one with coding sequence (ENSE00001668258).

	##calculate the start position of cds with method A
	#total length of the first coding exon
	total_length_first_coding_exon_2 = first_coding_exon_2$exon_chrom_end - first_coding_exon_2$exon_chrom_start + 1 #equal to 161, like the transcript length of this exon accoding to ensemnl (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000414683)
	#length of the non coding region in the first coding exon
	noncoding_region_first_coding_exon_2 = total_length_first_coding_exon_2 - first_coding_exon_2$cds_end
		#158 non-coding bases, and hence 3 coding bases (161-158=3). 3 is exactly the number of coding bases in the first coding exon (ATG) according to the webpage.
			#note that the orange bases in the translated sequence (blue) indicate that in that position a SNP exist (different possibilities for that base) leading to a change in the aminoacid codified
	#position of the start codign sequence
	start_cds_position_method_a_2 = first_coding_exon_2$exon_chrom_start + noncoding_region_first_coding_exon_2 #we are summing A and [A,B), both contains A but not B, so the result will give B and we dont have to sum 1.

	#calculate the start position of cds with method B
	start_cds_position_method_b_2 = first_coding_exon_2$exon_chrom_end - first_coding_exon_2$cds_end + 1 #from the end, we substract the whole coding region (including B, the beigining of the coding region), this would lead to the last base of the non-codign region, because of this we sum 1, the get the first base of the coding region.

	#check that both methods match
	start_cds_position_method_a_2 == start_cds_position_method_b_2

	##calculate the end position of cds with method A
	#total length of the last coding exon
	total_length_last_coding_exon_2 = last_coding_exon_2$exon_chrom_end - last_coding_exon_2$exon_chrom_start + 1 #equal to 148, like the transcript length of this exon accoding to ensemnl (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000414683). The whole exon is coding.
	#length of the coding region in the last coding exon
	coding_region_last_coding_exon_2 = last_coding_exon_2$cds_end - last_coding_exon_2$cds_start + 1
		#148, which is cogruent the 148 coding bases indicated in the webpage for this exon. The whole exon is coding, so 148 is also the length of the transcript.
	#length of the non-coding region in the last coding exon
	noncoding_region_last_coding_exon_2 = total_length_last_coding_exon_2 - coding_region_last_coding_exon_2 
	#position of the end coding sequence with method A
	end_cds_position_method_a_2 = last_coding_exon_2$exon_chrom_end - noncoding_region_last_coding_exon_2 #we are substracting a reange of values (F and (E,F]) that does not include E, thus the result will cinlude E and we do not have to sum 1

	#calculate the start position of cds with method B
	length_coding_sequence_last_coding_exon_2 = last_coding_exon_2$cds_end - last_coding_exon_2$cds_start + 1
	end_cds_position_method_b_2 = last_coding_exon_2$exon_chrom_start + length_coding_sequence_last_coding_exon_2 - 1 #we rest 1 becase the two ranges (D and [D,E]) we are summing both containts D, so we have to substract 1

	#check that both methods match
	end_cds_position_method_a_2 == end_cds_position_method_b_2


	## Calculate the length of all exons between the first and last coding exon

	#extract the exons between the extremes of the coding region
	exons_between_coding_extremes_2 = test_data_cds_2[-which(is.na(test_data_cds_2$cds_start) | test_data_cds_2$cds_start == 1 | test_data_cds_2$cds_end == unique(test_data_cds_2$cds_length)),] #remove those exons that are not coding (cds_start is NA), the first coding exon (cds_start=1) and the last coding exon (cds_end=total length of coding sequence). The remaining exons should be coding exons situated between the first and last coding exons, so they should be complete coding, i.e., no UTR sequence. 

	#extract the position of each exon between the extremes of the coding region
	exon_length_df_2 = data.frame(exon_name=NA, exon_length=NA)
	#for each exon with the extremes
	for(i in 1:nrow(exons_between_coding_extremes_2)){

		#sleect the [i] exon
		selected_row = exons_between_coding_extremes_2[i,]

		#calculate the length of the [i] exon
		exon_length = selected_row$exon_chrom_end - selected_row$exon_chrom_start + 1

		#save exon name
		exon_name = selected_row$ensembl_exon_id

		#calculate the length of the [i] exon as end less start adding 1 to include both extremes and save it
		exon_length_df_2 = rbind.data.frame(exon_length_df_2, cbind.data.frame(exon_name, exon_length))
	}
	#remove the frost row with NAs
	exon_length_df_2 = exon_length_df_2[-1,]
	exon_length_df_2
		#the length of each exon correspond with the transcript length of each one in the webpage (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000414683). The 5 exons between the first and last coding exons are entire coding, so transcript and exon length matches (all bases are blue).

	## Calculate total length of coding sequence and check with cds_length from ensemble
	#Sum the length of all exons of the middle plus the length of the coding sequence of the first exon plus the length of the coding sequence of the last coding exon
	length_coding_sequence_first_coding_exon_2 = first_coding_exon_2$exon_chrom_end - start_cds_position_method_a_2 + 1 #length of the sequence between the end of the first exon and the begining of the coding sequence in that exon. Remember that the coding sequence begins within this exon, so a part of the exon at the begining can be non-coding.
	length_coding_sequence_last_coding_exon_2 = end_cds_position_method_a_2 - last_coding_exon_2$exon_chrom_start + 1 #length of the sequence between the end of the coding sequence in the last coding exon and the start of that exon. Remember that the coding sequence ends within this exon, so a part of the exon at the end can be non-coding.
	total_cds_2 = sum(exon_length_df_2$exon_length) + length_coding_sequence_first_coding_exon_2 + length_coding_sequence_last_coding_exon_2

	#check that matches with cds_length from ensemble
	total_cds_2 == unique(test_data_cds_2$cds_length)


	## bind the position of each coding sequence

	#bind in one row the following data of the FIRST coding exon: exon id, start position of coding sequence (which can be in the middle of the exon) and the end of that exon (if there are more than 1 coding exon, the coding sequences will continue in other exons)
	first_coding_exon_positions_2 = cbind.data.frame(first_coding_exon_2$ensembl_exon_id, start_cds_position_method_a_2, first_coding_exon_2$exon_chrom_end, first_coding_exon_2$cds_start, first_coding_exon_2$cds_end)

	#bind in one row the following data of the coding exons BETWEEN the first and last exons: exon id, the start and end of these exons (the begining of the coding sequence is before and the end is later)
	exons_between_coding_extremes_positions_2 = cbind.data.frame(exons_between_coding_extremes_2$ensembl_exon_id, exons_between_coding_extremes_2$exon_chrom_start, exons_between_coding_extremes_2$exon_chrom_end, exons_between_coding_extremes_2$cds_start, exons_between_coding_extremes_2$cds_end)

	#bind in one row the following data of the LAST coding exon: exon id, start position of coding sequence (the begining of the codng sequence began in previous exons) and the end of the coding sequence (which can be in the middle of the exon)	
	last_coding_exon_positions_2 = cbind.data.frame(last_coding_exon_2$ensembl_exon_id, last_coding_exon_2$exon_chrom_start, end_cds_position_method_a_2, last_coding_exon_2$cds_start, last_coding_exon_2$cds_end) #first the start position of the coding sequence in the first coding exon, then the start of all coding exons between the first/last coding exons, and finally the start of the last coding exon

	#prepare column names to bind the rows
	colnames(first_coding_exon_positions_2) <- c('ensembl_exon_id', 'start_position_coding', 'end_position_coding', 'cds_start', 'cds_end')
	colnames(exons_between_coding_extremes_positions_2) <- c('ensembl_exon_id', 'start_position_coding', 'end_position_coding', 'cds_start', 'cds_end')	
	colnames(last_coding_exon_positions_2) <- c('ensembl_exon_id', 'start_position_coding', 'end_position_coding', 'cds_start', 'cds_end')

	#bind all the rows into one data frame
	positions_coding_sequences_2 = rbind.data.frame(first_coding_exon_positions_2, exons_between_coding_extremes_positions_2, last_coding_exon_positions_2) #first the end position of the first coding exon, then the end of all coding exons between the first/last coding exons, and finally the end position of the coding sequence in the last coding exon

	##final checks
	#final checks that the sum of the lengths of this start/end positions matches with cds_length from ensemble
	sum(positions_coding_sequences_2$end_position_coding - positions_coding_sequences_2$start_position_coding + 1) == unique(test_data_cds_2$cds_length) #the summatory of the lengths of each sequence (end less start plus 1, i.e., complete range including both extremes) is equal to cds_length form ensemble.

	#final check to test that the length of the coding sequences I have obtained are the same than those of cds start and end position
	positions_coding_sequences_2$cds_end - positions_coding_sequences_2$cds_start + 1 == positions_coding_sequences_2$end_position_coding - positions_coding_sequences_2$start_position_coding + 1


### CALCULATION EXAMPLE WITH ENSG00000000457 (SCYL3) ###

	#This transcript is reverse, so the first coding exon according to position, has cds_start == cds_length, whilst the last coding exon has cds_start == 1. I have checked that the positions are correct, is inverted. BUT, the start/end of each exon is correct

	#Coding example with the transcript ENST00000367770 of SCYL3 (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000000457;r=1:169818772-169863093;t=ENST00000367770)
	test_data_cds_3 = full_exon_data[which(full_exon_data$ensembl_gene_id == 'ENSG00000000457' & full_exon_data$ensembl_transcript_id == 'ENST00000367770'),]
	test_data_cds_3

	#check that the strand is reverse if we only have 1 type of strand (the whole transcript should be in the same sense)
	if(length(unique(test_data_cds_3$strand)) == 1){

		#check that the strand is reverse
		unique(test_data_cds_3$strand) == -1
	}


	## Calculate the start/end position of the first and last coding exons

	#select the last exon with coding sequence (cds_end == to the total cds length) and that it is not the first coding exon. This is made for the cases of genes with only one coding exon. In that way, that unique exon is only considered one time, becuase otherwise the unique exon would satisfy conditions for the first and last coding exon (cds start == 1 and cds end == cds length)
	first_coding_exon_3 = test_data_cds_3[which(test_data_cds_3$cds_end == test_data_cds_3$cds_length & test_data_cds_3$cds_start != 1),] 
		#This is the first one with coding sequence (ENSE00001445605).

	#select the first exon with coding sequence (cds_start == 1)
	last_coding_exon_3 = test_data_cds_3[which(test_data_cds_3$cds_start == 1),]
		#The last exon of this transcript with coding suquence -> ENSE00001445604

	##calculate the start position of cds
	#length of the coding region in the last coding exon
	coding_region_first_coding_exon_3 = first_coding_exon_3$cds_end - first_coding_exon_3$cds_start + 1
		#60, which is cogruent the 60 coding bases indicated in the webpage for this exon.

	#calculate the start position of coding sequence. 
	start_cds_position_3 = first_coding_exon_3$exon_chrom_end - coding_region_first_coding_exon_3 + 1 #we first substract from the end of the first coding exon the whole length of the coding sequence in that exon. Then we have to sum 1, this is the explanation: C is the end of the first coding exon and also cds_end, B is cds_start. C-B + 1 gives the total length of coding region in taht exon, from the first coding basis to the last one at the end of the exon, i.e., [B,C], including both extremes. Therefore, We are substracting from C a range of vales that also include C, thus we have to returned adding 1.


	##calculate the end position of cds
	#length of the coding region in the last coding exon
	coding_region_last_coding_exon_3 = last_coding_exon_3$cds_end - last_coding_exon_3$cds_start + 1
		#165, which is cogruent the 165 coding bases indicated in the webpage for this exon.

	#calculate the start position of coding sequence. 
	end_cds_position_3 = last_coding_exon_3$exon_chrom_start + coding_region_last_coding_exon_3 - 1 #we first sum from the start of the last coding exon the whole length of the coding sequence in that exon. Then we have to substract 1, this is the explanation: D is the start of the last coding exon and also cds_start, E is cds_end. E-D + 1 gives the total length of coding region in taht exon, from the first coding basis to the last one at the end of the exon, i.e., [D,E], including both extremes. Therefore, We are summing from D a range of values that also include D, thus we have to remove substracting adding 1.


	## Calculate the length of all exons between the first and last coding exon

	#extract the exons between the extremes of the coding region
	exons_between_coding_extremes_3 = test_data_cds_3[-which(is.na(test_data_cds_3$cds_start) | test_data_cds_3$cds_start == 1 | test_data_cds_3$cds_end == unique(test_data_cds_3$cds_length)),] #remove those exons that are not coding (cds_start is NA), the first coding exon (cds_start=1) and the last coding exon (cds_end=total length of coding sequence). The remaining exons should be coding exons situated between the first and last coding exons, so they should be complete coding, i.e., no UTR sequence. 

	#reorder in basis on position to get the same order of the intermediate exons than in the ensemble database
	exons_between_coding_extremes_3 = exons_between_coding_extremes_3[order(exons_between_coding_extremes_3$exon_chrom_start, decreasing=TRUE),] #We use decreasing=TRUE because we want the last exons (higher position number) at the beining. This is the order in the ensemble webpage. 

	#extract the position of each exon between the extremes of the coding region
	exon_length_df_3 = data.frame(exon_name=NA, exon_length=NA)
	#for each exon with the extremes
	for(i in 1:nrow(exons_between_coding_extremes_3)){

		#sleect the [i] exon
		selected_row = exons_between_coding_extremes_3[i,]

		#calculate the length of the [i] exon
		exon_length = selected_row$exon_chrom_end - selected_row$exon_chrom_start + 1

		#save exon name
		exon_name = selected_row$ensembl_exon_id

		#calculate the length of the [i] exon as end less start adding 1 to include both extremes and save it
		exon_length_df_3 = rbind.data.frame(exon_length_df_3, cbind.data.frame(exon_name, exon_length))
	}
	#remove the frost row with NAs
	exon_length_df_3 = exon_length_df_3[-1,]
	exon_length_df_3
		#the length of each exon correspond with the transcript length of each one in the webpage (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000000457;r=1:169818772-169863093;t=ENST00000367770). The 11 exons between the first and last coding exons are entire coding, so transcript and exon length matches (all bases are blue).

	## Calculate total length of coding sequence and check with cds_length from ensemble
	#Sum the length of all exons of the middle plus the length of the coding sequence of the first exon plus the length of the coding sequence of the last coding exon
	length_coding_sequence_first_coding_exon_3 = first_coding_exon_3$exon_chrom_end - start_cds_position_3 + 1 #length of the sequence between the end of the first exon and the begining of the coding sequence in that exon. Remember that the coding sequence begins within this exon, so a part of the exon at the begining can be non-coding.
	length_coding_sequence_last_coding_exon_3 = end_cds_position_3 - last_coding_exon_3$exon_chrom_start + 1 #length of the sequence between the end of the coding sequence in the last coding exon and the start of that exon. Remember that the coding sequence ends within this exon, so a part of the exon at the end can be non-coding.
	total_cds_3 = sum(exon_length_df_3$exon_length) + length_coding_sequence_first_coding_exon_3 + length_coding_sequence_last_coding_exon_3

	#check that matches with cds_length from ensemble
	total_cds_3 == unique(test_data_cds_3$cds_length)


	## bind the position of each coding sequence

	#bind in one row the following data of the FIRST coding exon: exon id, start position of coding sequence (which can be in the middle of the exon) and the end of that exon (if there are more than 1 coding exon, the coding sequences will continue in other exons)
	first_coding_exon_positions_3 = cbind.data.frame(first_coding_exon_3$ensembl_exon_id, start_cds_position_3, first_coding_exon_3$exon_chrom_end, first_coding_exon_3$cds_start, first_coding_exon_3$cds_end)

	#bind in one row the following data of the coding exons BETWEEN the first and last exons: exon id, the start and end of these exons (the begining of the coding sequence is before and the end is later)
	exons_between_coding_extremes_positions_3 = cbind.data.frame(exons_between_coding_extremes_3$ensembl_exon_id, exons_between_coding_extremes_3$exon_chrom_start, exons_between_coding_extremes_3$exon_chrom_end, exons_between_coding_extremes_3$cds_start, exons_between_coding_extremes_3$cds_end)

	#bind in one row the following data of the LAST coding exon: exon id, start position of coding sequence (the begining of the codng sequence began in previous exons) and the end of the coding sequence (which can be in the middle of the exon)	
	last_coding_exon_positions_3 = cbind.data.frame(last_coding_exon_3$ensembl_exon_id, last_coding_exon_3$exon_chrom_start, end_cds_position_3, last_coding_exon_3$cds_start, last_coding_exon_3$cds_end) #first the start position of the coding sequence in the first coding exon, then the start of all coding exons between the first/last coding exons, and finally the start of the last coding exon

	#prepare column names to bind the rows
	colnames(first_coding_exon_positions_3) <- c('ensembl_exon_id', 'start_position_coding', 'end_position_coding', 'cds_start', 'cds_end')
	colnames(exons_between_coding_extremes_positions_3) <- c('ensembl_exon_id', 'start_position_coding', 'end_position_coding', 'cds_start', 'cds_end')	
	colnames(last_coding_exon_positions_3) <- c('ensembl_exon_id', 'start_position_coding', 'end_position_coding', 'cds_start', 'cds_end')

	#bind all the rows into one data frame
	positions_coding_sequences_3 = rbind.data.frame(first_coding_exon_positions_3, exons_between_coding_extremes_positions_3, last_coding_exon_positions_3) #first the end position of the first coding exon, then the end of all coding exons between the first/last coding exons, and finally the end position of the coding sequence in the last coding exon

	##final checks
	#final checks that the sum of the lengths of this start/end positions matches with cds_length from ensemble
	sum(positions_coding_sequences_3$end_position_coding - positions_coding_sequences_3$start_position_coding + 1) == unique(test_data_cds_3$cds_length) #the summatory of the lengths of each sequence (end less start plus 1, i.e., complete range including both extremes) is equal to cds_length form ensemble.

	#final check to test that the length of the coding sequences I have obtained are the same than those of cds start and end position
	positions_coding_sequences_3$cds_end - positions_coding_sequences_3$cds_start + 1 == positions_coding_sequences_3$end_position_coding - positions_coding_sequences_3$start_position_coding + 1



#####################################################################################
#### CALCULATING THE LENGTH OF CODING REGIONS USING GENOMIC CODING START AND END ####
#####################################################################################

#Calculate coding density using genomic coding start/end instead of cds start/end and compare results
#cds start/end gives you the number of coding bases at the beginning and end of the coding sequence in each coding exon, but it does not give position of start and of these sequences. Genomic start and end gives you exactly the position of start and end of the coding sequence in each coding exon

#In addition, I think that cds start and end, only considers the order of the strand. If the strand is negative, the last coding exons in coordinates will be the first one according to cds start (cds_start=1). In contrast, genomic start considers the coordinates of the positive strand always.


## SEMA4A_1
#extract the exon data of the ENST00000435124 transcript of SEMA4A_1
test_genomic_start_end_sema4a_1 = sema4a_exon_data_indv_query[which(sema4a_exon_data_indv_query$ensembl_transcript_id == 'ENST00000435124'),]
test_genomic_start_end_sema4a_1

#remove the exons without any coding sequence
test_genomic_start_end_sema4a_1 = test_genomic_start_end_sema4a_1[which(!is.na(test_genomic_start_end_sema4a_1$genomic_coding_start) | !is.na(test_genomic_start_end_sema4a_1$genomic_coding_end)),]

#reorder en basis on position
test_genomic_start_end_sema4a_1 = test_genomic_start_end_sema4a_1[order(test_genomic_start_end_sema4a_1$cds_start),]

#calculate the complete length of each coding region according to genomic coding start/end
coding_length_by_genom_start_end_sema4a_1 = test_genomic_start_end_sema4a_1$genomic_coding_end - test_genomic_start_end_sema4a_1$genomic_coding_start + 1 #we sum 1 because we want the complete range
coding_length_by_genom_start_end_sema4a_1 #First coding exon (ENSE00003474176) has a coding sequence of 139 bases, which is exactly the number of blue bases indicated in the webpage of ensemble. The rest has exactly the same coding length than that indicated in the webpage (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000435124).

#check that the the complete range of coding sequences according to genomic start/start is similar to that calculated with cds start/end
summary(coding_length_by_genom_start_end_sema4a_1 == (test_genomic_start_end_sema4a_1$cds_end - test_genomic_start_end_sema4a_1$cds_start + 1)) #we sum 1 because we want the complete range

#check that the genomic starts and ends are the same than the ranges I have calculated using cds start/end
#bind both dataset (one with ranges calculated by me and another with the genomic start/end data)
test_genomic_start_end_sema4a_merge_positions_coding_sequences = merge(test_genomic_start_end_sema4a_1, positions_coding_sequences, by='ensembl_exon_id')
#make the check
summary(test_genomic_start_end_sema4a_merge_positions_coding_sequences$genomic_coding_start == test_genomic_start_end_sema4a_merge_positions_coding_sequences$start_position_coding)
summary(test_genomic_start_end_sema4a_merge_positions_coding_sequences$genomic_coding_end == test_genomic_start_end_sema4a_merge_positions_coding_sequences$end_position_coding)


## SEMA4A_2
#extract the exon data of the ENST00000414683 transcript of SEMA4A_2
test_genomic_start_end_sema4a_2 = sema4a_exon_data_indv_query[which(sema4a_exon_data_indv_query$ensembl_transcript_id == 'ENST00000414683'),]
test_genomic_start_end_sema4a_2

#remove the exons without any coding sequence
test_genomic_start_end_sema4a_2 = test_genomic_start_end_sema4a_2[which(!is.na(test_genomic_start_end_sema4a_2$genomic_coding_start) | !is.na(test_genomic_start_end_sema4a_2$genomic_coding_end)),]

#reorder en basis on position
test_genomic_start_end_sema4a_2 = test_genomic_start_end_sema4a_2[order(test_genomic_start_end_sema4a_2$cds_start),]

#calculate the complete length of each coding region according to genomic coding start/end
coding_length_by_genom_start_end_sema4a_2 = test_genomic_start_end_sema4a_2$genomic_coding_end - test_genomic_start_end_sema4a_2$genomic_coding_start + 1 #we sum 1 because we want the complete range
coding_length_by_genom_start_end_sema4a_2 
	#First coding exon (ENSE00003589564) has a coding sequence of 3 bases, which is exactly the number of blue bases indicated in the webpage of ensemble. The rest has exactly the same coding length than that indicated in the webpage (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000196189;r=1:156117157-156147543;t=ENST00000414683). 

#check that the the complete range of coding sequences accroding to genomic start/start is similar to that calculated with cds start/end
summary(coding_length_by_genom_start_end_sema4a_2 == (test_genomic_start_end_sema4a_2$cds_end - test_genomic_start_end_sema4a_2$cds_start + 1)) #we sum 1 because we want the complete range

#check that the genomic starts and ends are the same than the ranges I have calculated
#bind both dataset (one with ranges calculated by me and another with the genomic start/end data)
test_genomic_start_end_sema4a_2_merge_positions_coding_sequences_2 = merge(test_genomic_start_end_sema4a_2, positions_coding_sequences_2, by='ensembl_exon_id')
#make the check
summary(test_genomic_start_end_sema4a_2_merge_positions_coding_sequences_2$genomic_coding_start == test_genomic_start_end_sema4a_2_merge_positions_coding_sequences_2$start_position_coding)
summary(test_genomic_start_end_sema4a_2_merge_positions_coding_sequences_2$genomic_coding_end == test_genomic_start_end_sema4a_2_merge_positions_coding_sequences_2$end_position_coding)


## SCYL3
#Coding example with the transcript ENST00000367770 of SCYL3 (http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000000457;r=1:169818772-169863093;t=ENST00000367770)
test_genomic_start_end_scyl3 = full_exon_data[which(full_exon_data$ensembl_gene_id == 'ENSG00000000457' & full_exon_data$ensembl_transcript_id == 'ENST00000367770'),]
test_genomic_start_end_scyl3

#remove the exons without any coding sequence
test_genomic_start_end_scyl3 = test_genomic_start_end_scyl3[which(!is.na(test_genomic_start_end_scyl3$genomic_coding_start) | !is.na(test_genomic_start_end_scyl3$genomic_coding_end)),]

#reorder en basis on position
test_genomic_start_end_scyl3 = test_genomic_start_end_scyl3[order(test_genomic_start_end_scyl3$exon_chrom_start, decreasing=TRUE),]

#calculate the complete length of each coding region according to genomic coding start/end
coding_length_by_genom_start_end_scyl3 = test_genomic_start_end_scyl3$genomic_coding_end - test_genomic_start_end_scyl3$genomic_coding_start + 1 #we sum 1 because we want the complete range
coding_length_by_genom_start_end_scyl3
	#First coding exon (ENSE00003589564) has a coding sequence of 165 bases, which is exactly the number of blue bases indicated in the webpage of ensemble. The last coding exon has 12 coding bases only. The rest coding exons have exactly the same coding length than that indicated in the webpage (https://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000000457;r=1:169822215-169858029;t=ENST00000367770). 

#check that the the complete range of coding sequences according to genomic start/start is similar to that calculated with cds start/end
summary(coding_length_by_genom_start_end_scyl3 == (test_genomic_start_end_scyl3$cds_end - test_genomic_start_end_scyl3$cds_start + 1)) #we sum 1 because we want the complete range

#check that the genomic starts and ends are the same than the ranges I have calculated
#bind both dataset (one with ranges calculated by me and another with the genomic start/end data)
test_genomic_start_end_scyl3_merge_positions_coding_sequences_scyl3 = merge(test_genomic_start_end_scyl3, positions_coding_sequences_3, by='ensembl_exon_id')
#make the check
summary(test_genomic_start_end_scyl3_merge_positions_coding_sequences_scyl3$genomic_coding_start == test_genomic_start_end_scyl3_merge_positions_coding_sequences_scyl3$start_position_coding)
summary(test_genomic_start_end_scyl3_merge_positions_coding_sequences_scyl3$genomic_coding_end == test_genomic_start_end_scyl3_merge_positions_coding_sequences_scyl3$end_position_coding)



########################################################################################
###### CHECK THE EXISTENCE OF SOME GENES AND TRANSCRIPTS THAT ARE NOT TRANSLATED #######
########################################################################################

#extract the unique cases of gene and transcript type
unique_gene_types = unique(full_exon_data$gene_biotype)
unique_transcript_types = unique(full_exon_data$transcript_biotype)

#gene and transcript types are not exactly the same. All gene types are included in the transcript types, but some transcript types are not included in the gene types
unique_gene_types %in% unique_transcript_types
unique_transcript_types %in% unique_gene_types

### see what types of genes have only NA for cds_length ###
#for each gene types
test_gene_type_cds_length = data.frame(selected_gene_type=NA, result_test=NA)
for(i in 1:length(unique_gene_types)){

	#select the [i] gene type
	selected_gene_type = unique_gene_types[i]

	#extract the exons belonging to gene of the [i] gene type
	cds_lengths = full_exon_data[which(full_exon_data$gene_biotype == selected_gene_type),]$cds_length

	#test if all lengths of coding sequences are equal to NA for this type
	result_test = all(is.na(cds_lengths))

	#save the results
	test_gene_type_cds_length = rbind.data.frame(test_gene_type_cds_length, cbind.data.frame(selected_gene_type, result_test))
} 	

#remove first row with NAs
test_gene_type_cds_length = test_gene_type_cds_length[-1,]

#take a look to case with ALL NA for coding sequence length
test_gene_type_cds_length[which(test_gene_type_cds_length$result_test == TRUE),]

### see what types of transcripts have only NA for cds_length ###
#for each type of transcript
test_transcript_type_cds_length = data.frame(selected_transcript_type=NA, result_test=NA)
for(i in 1:length(unique_transcript_types)){

	#select the [i] transcript type
	selected_transcript_type = unique_transcript_types[i]

	#extract the exons belonging to transcript of the [i] transcript type
	cds_lengths = full_exon_data[which(full_exon_data$transcript_biotype == selected_transcript_type),]$cds_length

	#test if all lengths of coding sequences are equal to NA for this type
	result_test = all(is.na(cds_lengths))

	#save the results
	test_transcript_type_cds_length	= rbind.data.frame(test_transcript_type_cds_length, cbind.data.frame(selected_transcript_type, result_test))
}	

#remove first row with NAs
test_transcript_type_cds_length = test_transcript_type_cds_length[-1,]

#take a look to case with ALL NA for coding sequence length
test_transcript_type_cds_length[which(test_transcript_type_cds_length$result_test == TRUE),] #I have found that for many gene and transcript types have only NA data for coding sequence length. These sequences are not translated. For example, ENST00000485575 of SEMA4A-008, which has no translation length (http://grch37.ensembl.org/Homo_sapiens/Transcript/Summary?db=core;g=ENSG00000196189;r=1:156119994-156126365;t=ENST00000485575)
	#Removing these gene types would lead to consider genes that are not coding
		#Non-coding genes will be removed.
	#Removing these transcript types would not affect to coding density withing a coding gene if we use coding sequence length, as these transcript types have NA for that variable. The problem I see is that one of this transcript is at the end or beginning of a gene, then we would be considering non-coding regions for gene size. This would affect to gene length and the calculation of the center. I would REMOVE all the rows without cds_length data. Line 200.
		#David said that for gene center we can use the full gene length according gene start and end, but for coding density we need to avoid these transcripts. 

#gene and transcript biotypes removing those cases with cds_length all NA
unique(full_exon_data[which(!is.na(full_exon_data$cds_length)),]$gene_biotype)
unique(full_exon_data[which(!is.na(full_exon_data$cds_length)),]$transcript_biotype)

#check for non-functional transcripts
	#I have found some genes with coding sequences, but that are not functional, like a inmunglobulin gene (IGHV1OR15-9; ENSG00000188403; http://grch37.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000188403;r=15:20169919-20170354;t=ENST00000338912).
		#Do you think we should get ride of them? I am not very sure if there a filter or attribute to remove non functional transcripts. I have seen it in some gene types that include in their name the label variable (i guess too much variability in the sequence) like TR_V_gene (T cell receptor gamma variable) or IG_V_gene (immunoglobulin variable), but not in other genes of the variable category (ENST00000390633). In other types like T cell receptor gamma joining (TR_J_gene) or T cell receptor delta diversity (TR_D_gene) i have found functional proteins
		#I don´t understand why these cases have a different gene type from protein coding...
head(full_exon_data[which(!is.na(full_exon_data$cds_length) & full_exon_data$transcript_biotype == 'IG_V_gene'),], 100)
head(full_exon_data[which(!is.na(full_exon_data$cds_length) & full_exon_data$transcript_biotype == 'TR_V_gene'),], 100)
head(full_exon_data[which(!is.na(full_exon_data$cds_length) & full_exon_data$transcript_biotype == 'TR_C_gene'),], 100)
head(full_exon_data[which(!is.na(full_exon_data$cds_length) & full_exon_data$transcript_biotype == 'TR_J_gene'),], 100)
head(full_exon_data[which(!is.na(full_exon_data$cds_length) & full_exon_data$transcript_biotype == 'TR_D_gene'),], 100)

#transcripts with decay and pseudogenes
head(full_exon_data[which(!is.na(full_exon_data$cds_length) & full_exon_data$transcript_biotype == 'non_stop_decay'),], 100)
head(full_exon_data[which(!is.na(full_exon_data$cds_length) & full_exon_data$transcript_biotype == 'nonsense_mediated_decay'),], 100)
head(full_exon_data[which(!is.na(full_exon_data$cds_length) & full_exon_data$transcript_biotype == 'polymorphic_pseudogene'),], 100)
	#transcript with decay I guess means that these transcript are destroyed because have not stop codon or the stop codon is too soon. Am I right? We should consider this in our analyses?
	#Same goes for pseudogenes. A gene that has homology to known protein-coding genes but contain a frame shift and/or stop codon(s) which disrupts the open reading frame. Thought to have arisen through duplication followed by loss of function.

#This is the list of all transcript biotypes:
unique(full_exon_data$transcript_biotype)
	#list		
		#"protein_coding"                    
 		#"nonsense_mediated_decay"           
 		#"processed_transcript"              
 		#"miRNA"                             
 		#"processed_pseudogene"              
 		#"misc_RNA"                          
 		#"lincRNA"                           
 		#"snRNA"                             
 		#"snoRNA"                            
		#"antisense"                         
		#"rRNA"                              
		#"transcribed_unprocessed_pseudogene"
		#"transcribed_processed_pseudogene"  
		#"unprocessed_pseudogene"            
		#"sense_intronic"                    
		#"pseudogene"                        
		#"retained_intron"                   
		#"unitary_pseudogene"                
		#"sense_overlapping"                 
		#"IG_V_gene"                         
		#"IG_D_gene"                         
		#"3prime_overlapping_ncrna"          
		#"IG_V_pseudogene"                   
		#"non_stop_decay"                    
		#"polymorphic_pseudogene"            
		#"Mt_tRNA"                           
		#"Mt_rRNA"                           
		#"TR_V_pseudogene"                   
		#"IG_C_pseudogene"                   
		#"TR_C_gene"                         
		#"TR_J_gene"                         
		#"TR_V_gene"                         
		#"TR_J_pseudogene"                   
		#"translated_processed_pseudogene"   
		#"IG_J_pseudogene"                   
		#"IG_J_gene"                         
		#"IG_C_gene"                         
		#"TR_D_gene"
		#def of gene types: https://uswest.ensembl.org/info/genome/genebuild/biotypes.html
	
	#Should we remove all this types and only use protein coding? I know that between these categories there are non-functional proteins, but not sure if all of them.. should I revise each type to ensure that these types of sequences have no influence on phenotype?
		#YES, we only want coding genes. For transcripts withing coding-functional genes, we will also remove this type of transcripts. We do not want them in coding density calculation. For gene length, we will use gene start and end, so it could include them, but it is not problematic (small changes of length and center...)

#select those rows without NA for coding sequence length and with gene and transcript type equal to protein coding
full_exon_data_filtered = full_exon_data[which(!is.na(full_exon_data$cds_length) & full_exon_data$gene_biotype == 'protein_coding' & full_exon_data$transcript_biotype == 'protein_coding'),]
head(full_exon_data_filtered)

#check the difference in size
length(unique(full_exon_data$ensembl_gene_id))
length(unique(full_exon_data_filtered$ensembl_gene_id))
length(unique(full_exon_data$ensembl_gene_id)) - length(unique(full_exon_data_filtered$ensembl_gene_id))

#check
all(!is.na(full_exon_data_filtered$cds_length)) #No NA in coding sequence length
unique(full_exon_data_filtered$gene_biotype) #only protein coding
unique(full_exon_data_filtered$transcript_biotype) #only protein coding in transcript biotype.

#As we remove all sequences without data for cds. if a transcript have at least one coding exon, will have cds value and it will be included. This cds value will not count for the non-coding bases inside the coding exon like the 5´ UTR extreme, etc.. See figures 11 and 15 (the 3´ and 5´ below of the line i think that refer to the other strand).

#For gene length and center, we count these non-coding sequences inside the coding exons along with non-functional transcripts we use gene start and end, but according to David this is not a problem. The difference in size and center position will be small in relation to the LD blocks in the human genome (thousands of bases).



##############################################################################
###### FILTER GENE LIST USING THE PREVIOUS FILTER APPLIES ON EXON DATA #######
##############################################################################

#We are going to filter the gene list all_genes_grch37_human_filtered removing those id genes that are not included in our exon data, i.e., non coding genes or genes without protein coding transcripts.

#note that you can have exon data from genes in the sexual chromosomes, but the all_genes_grch37_human_filtered list is already filtered for that. Therefore, the loop for calculating windows and coding density will only use autosomal genes. Only coding density of autosomal genes will be calculated. 

#REMEMBER: "all_genes_grch37_human_filtered" determine the genes that will be used in the analyses. 

#extract from all_genes_grch37_human_filtered, i.e., dataframe with the gene names data, those rows with an gene id included in the filtered dataset with exon data.
all_genes_grch37_exon_filter = all_genes_grch37_human_filtered[which(all_genes_grch37_human_filtered$ensembl_gene_id %in% unique(full_exon_data_filtered$ensembl_gene_id)),]

#check that the filtering occurred well
summary(unique(all_genes_grch37_exon_filter$ensembl_gene_id) %in% unique(full_exon_data_filtered$ensembl_gene_id))
summary(unique(full_exon_data_filtered$ensembl_gene_id) %in% unique(all_genes_grch37_exon_filter$ensembl_gene_id))

#some genes of the exon data are not included in the list of genes
#extract the list of lost genes in exon data, i.e., genes that are includqed in the exon data but not in the gene list
lost_genes = full_exon_data_filtered[which(!full_exon_data_filtered$ensembl_gene_id %in% unique(all_genes_grch37_exon_filter$ensembl_gene_id)),]$ensembl_gene_id
#extract the exon data of these genes
exon_data_lost_genes = full_exon_data_filtered[which(full_exon_data_filtered$ensembl_gene_id %in% lost_genes),]
#take a look
head(exon_data_lost_genes, 100)
exon_data_lost_genes[1,] #the first one is form X chromosome.
unique(exon_data_lost_genes$chromosome_name) #but there are also from Y chromosome and patches from areas with high variability.


#We also have a gene id of SLC25A26 (ENSG00000261657). This is id is not included the filtered gene list but the hgcs symbol does!!
exon_data_lost_genes[which(exon_data_lost_genes$ensembl_gene_id == 'ENSG00000261657'),]

#These genes id are not included in all_genes_grch37_exon_filter because we removed those that have not 1:22 or X in chromosome data. There are some regions with great variability like the MHC for which different patches are included. Also fixing patches are created. similar, genes of the Y and X chromosome are not included. We have removed all of this in all_genes_grch37_exon_filter. Therefore, they will be not used in the analyses!

#If you look for SLC25A26 in the filtered gene list, you will obtain a gene id that is already included exon data.
all_genes_grch37_exon_filter[which(all_genes_grch37_exon_filter$hgnc_symbol == 'SLC25A26'),]$ensembl_gene_id #gene id is ENSG00000144741 
	#According to the biomart online server, ENSG00000144741 is SLC25A26, a gene of the chromosome 3, while ENSG00000261657 is also SLC25A26, but its chromosome name is Chromosome HG991_PATCH, i.e., it is a patch. 

#THEREFORE, if we use the gene list as a guide for searching genes, we will have these genes but NOT the patches. 

#remove these patches and the X-Y chromosome from exon data
full_exon_data_filtered_final = full_exon_data_filtered[which(full_exon_data_filtered$ensembl_gene_id %in% unique(all_genes_grch37_exon_filter$ensembl_gene_id)),]

#check that the X and Y chromosome are not included. 
c("X", "Y") %in% unique(full_exon_data_filtered_final$chromosome_name)

#check that only genes included in the gene list are present in the exon data
summary(full_exon_data_filtered_final$ensembl_gene_id %in% all_genes_grch37_exon_filter$ensembl_gene_id)
summary(all_genes_grch37_exon_filter$ensembl_gene_id %in% full_exon_data_filtered_final$ensembl_gene_id)


### Remove the genes and transcript from gene list that not produce coding protein ###

#select those transcript that belong to coding genes and produce proteins, i.e., gene and transcript biotype equal to 'protein_coding'
coding_transcripts = full_exon_data_filtered_final[which(full_exon_data_filtered_final$gene_biotype == 'protein_coding' & full_exon_data_filtered_final$transcript_biotype == 'protein_coding'),]$ensembl_transcript_id
length(coding_transcripts) == nrow(full_exon_data_filtered_final) #all the rows of full_exon_data_filtered_final satisfy the condition of having gene and transcript biotype as 'protein_coding'

#select from the gene list those rows belonging to these coding transcripts
all_genes_grch37_exon_filter_final = all_genes_grch37_exon_filter[which(all_genes_grch37_exon_filter$ensembl_transcript_id %in% unique(coding_transcripts)),] #If a gene has an coding transcript, it will be included because that transcript will have as biotype 'protein_coding' and the gene biotype will be 'protein_coding'

#check 
summary(all_genes_grch37_exon_filter_final$ensembl_transcript_id %in% full_exon_data_filtered_final$ensembl_transcript_id)
summary(full_exon_data_filtered_final$ensembl_transcript_id %in% all_genes_grch37_exon_filter_final$ensembl_transcript_id)

#check for no name genes (no hgnc symbol) that remained after applying the filter 
nrow(all_genes_grch37_exon_filter_final[which(all_genes_grch37_exon_filter_final$hgnc_symbol == ''),])
	#There are cases of uncharacterized proteins like AP000350.10 (ENSG00000251357)
	#These are proteins that are not very well studied and we don´t know their function, but according to David we should include them. They are translated, and can be under selection...

#Resuming:
	#I have selected coding data data for coding density. This does NOT include non-coding genes, non-coding transcripts, non-functional transcripts (biotype different from coding protein), and the non-coding regions inside the coding exons. 
	#BUT for gene length I am using gene start and end, which can include in the gene length some areas of non-coding or non-functional transcripts. I think you told me that this only changes the gene length and center position of a few bases, which is nothing compare to the bigger size of LD blocks in human genome.
	#That´s right?			
		#YES, that it is perfect.
	#Also we have removed genes whose chromosome names is not 1:22.



#######################################################
###### CHECKS FOR FILTERS IN THE FINAL DATASETS #######
#######################################################

### check that there is not row with other chromosome_name rather than 1:22 ###

#for all_genes_grch37_exon_filter_final
#check that no row has as a chromosome name different from 1:22
nrow(all_genes_grch37_exon_filter_final[which(!(all_genes_grch37_exon_filter_final$chromosome_name %in% c(1:22))),]) == 0 

#check that 1:22 are included as chromosome names
c(1:22) %in% unique(all_genes_grch37_exon_filter_final$chromosome_name)

#check that all chromosome names are included in 1:22
unique(all_genes_grch37_exon_filter_final$chromosome_name) %in% c(1:22)

#for full_exon_data_filtered_final
#chromosome names of the genes included in exon data
chromosome_names_exon_data = all_genes_grch37_exon_filter_final[which(all_genes_grch37_exon_filter_final$ensembl_gene_id %in% unique(full_exon_data_filtered_final$ensembl_gene_id)),]$chromosome_name

#check that 1:22 are included as chromosome names
c(1:22) %in% unique(chromosome_names_exon_data)

#check that all chromosome names are included in c(1:22)
unique(chromosome_names_exon_data) %in% c(1:22)


### check that all transcripts included has 'protein_coding' as biotype and cds_length is not NA ###

#check that the gene and transcript biotype in exon data is protein coding
unique(full_exon_data_filtered_final$gene_biotype) == 'protein_coding'
unique(full_exon_data_filtered_final$transcript_biotype) == 'protein_coding'

#extract the from the exon data those rows with gene id included in the gene list, and see if the gene biotype is protein coding
unique(full_exon_data_filtered_final[which(full_exon_data_filtered_final$ensembl_gene_id %in% unique(all_genes_grch37_exon_filter_final$ensembl_gene_id)),]$gene_biotype) == 'protein_coding'

#extract the from the exon data those rows with transcript id included in the gene list, and see if the transcript biotype is protein coding
unique(full_exon_data_filtered_final[which(full_exon_data_filtered_final$ensembl_transcript_id %in% unique(all_genes_grch37_exon_filter_final$ensembl_transcript_id)),]$transcript_biotype) == 'protein_coding'


#### check that each gene name has only one gene id. I can not select those cases without gene name ###

#extract the gene names without empty cases ('')
gene_names_no_null_v2 = unique(all_genes_grch37_exon_filter_final$hgnc_symbol)
gene_names_no_null_v2 = gene_names_no_null_v2[-which(gene_names_no_null_v2 == '')]
!'' %in% gene_names_no_null_v2
#for each gene name
test_duplicated_gene_id_v2 = data.frame(selected_gene_name=NA, test_result=NA)
for(i in 1:length(gene_names_no_null_v2)){

	#select the [i] gene name
	selected_gene_name = gene_names_no_null_v2[i]

	#extract the unique cases of gene id for the [i] hgnc symbol
	unique_gene_id = unique(all_genes_grch37_exon_filter_final[which(all_genes_grch37_exon_filter_final$hgnc_symbol == selected_gene_name),]$ensembl_gene_id)

	#test that the number of unique cases is 1 (only 1 gene id for each gene name)
	test_result = length(unique_gene_id) == 1

	#save
	test_duplicated_gene_id_v2 = rbind.data.frame(test_duplicated_gene_id_v2, cbind.data.frame(selected_gene_name, test_result))
}
#remove first row with NAs
test_duplicated_gene_id_v2 = test_duplicated_gene_id_v2[-1,]
#take a look for genes with repeated gene id
summary(test_duplicated_gene_id_v2) #we have several cases
#extract information of these genes
genes_with_duplicated_id_v2 = test_duplicated_gene_id_v2[which(test_duplicated_gene_id_v2$test_result == FALSE),]$selected_gene_name
all_genes_grch37_exon_filter_final[which(all_genes_grch37_exon_filter_final$hgnc_symbol %in% genes_with_duplicated_id_v2),]
	#As I thought, those repeated gene names for microRNAs have been removed after filtering.
	#We have only one case remaining which is not a microRNA: UGT2A1 has two gene ids, ENSG00000270386 (http://grch37.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000270386;r=4:70454912-70518967;t=ENST00000514019) and ENSG00000173610 (http://grch37.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000173610;r=4:70454135-70518965). It is like ENSG00000270386 is a transcript of ENSG00000270386 that has been separated as an independent gene. They are in the same region, and has the same hgnc symbol. 
		#I do not know what to do with the latter case. Should I removed the gene id with only one transcript, if not we will have the start of two windows in that region. Moreover, I don´t know how detect more cases like this in genes that have no hgnc symbol. 

	#According to David this is VERY rare. REMOVE THESE TWO GENES.

#remove UGT2A1 genes
all_genes_grch37_exon_filter_final = all_genes_grch37_exon_filter_final[-which(all_genes_grch37_exon_filter_final$ensembl_gene_id %in% c('ENSG00000270386', 'ENSG00000173610')),]
full_exon_data_filtered_final = full_exon_data_filtered_final[-which(full_exon_data_filtered_final$ensembl_gene_id %in% c('ENSG00000270386', 'ENSG00000173610')),]


#### check AGAIN that each gene name has only one gene id. I can not select those cases without gene name ###

#extract the gene names without empty cases ('')
gene_names_no_null_v2 = unique(all_genes_grch37_exon_filter_final$hgnc_symbol)
gene_names_no_null_v2 = gene_names_no_null_v2[-which(gene_names_no_null_v2 == '')]
!'' %in% gene_names_no_null_v2
#for each gene name
test_duplicated_gene_id_v2 = data.frame(selected_gene_name=NA, test_result=NA)
for(i in 1:length(gene_names_no_null_v2)){

	#select the [i] gene name
	selected_gene_name = gene_names_no_null_v2[i]

	#extract the unique cases of gene id for the [i] hgnc symbol
	unique_gene_id = unique(all_genes_grch37_exon_filter_final[which(all_genes_grch37_exon_filter_final$hgnc_symbol == selected_gene_name),]$ensembl_gene_id)

	#test that the number of unique cases is 1 (only 1 gene id for each gene name)
	test_result = length(unique_gene_id) == 1

	#save
	test_duplicated_gene_id_v2 = rbind.data.frame(test_duplicated_gene_id_v2, cbind.data.frame(selected_gene_name, test_result))
}
#remove first row with NAs
test_duplicated_gene_id_v2 = test_duplicated_gene_id_v2[-1,]
#take a look for genes with repeated gene id
summary(test_duplicated_gene_id_v2) #No several cases
#extract information of these genes
genes_with_duplicated_id_v2 = test_duplicated_gene_id_v2[which(test_duplicated_gene_id_v2$test_result == FALSE),]$selected_gene_name
all_genes_grch37_exon_filter_final[which(all_genes_grch37_exon_filter_final$hgnc_symbol %in% genes_with_duplicated_id_v2),]



###############################################
###### SAVE THE GENE LIST AND EXON DATA #######
###############################################

#save the list of genes
write.table(x=all_genes_grch37_exon_filter_final,file='/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/all_genes_grch37_exon_filter_final.txt', sep='\t', row.names=FALSE)

#save the exon data
write.table(x=full_exon_data_filtered_final,file='/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/full_exon_data_filtered_final.txt', sep='\t', row.names=FALSE)



######################################################################################################
###### RUN THE FUNCTION TO EXTRACT GENE POSITIONS AND SOME GENOMIC FACTORS FOR EACH CHROMOSOME #######
######################################################################################################

##load all the necessary data, so you can just run the script from here if you want to. 
#load the list of genes filtered
all_genes_grch37_exon_filter_final = read.table('/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/all_genes_grch37_exon_filter_final.txt', sep='\t', header=TRUE)
str(all_genes_grch37_exon_filter_final)

#load the exon data filtered
full_exon_data_filtered_final = read.table('/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/full_exon_data_filtered_final.txt', sep='\t', header=TRUE)
str(full_exon_data_filtered_final)

#load the chromosome length data to cut those windows that surpass the end of the chromosome (I will also cut those that surpass the start of the chromosome, i.e., negative bases)
chrom_length_ucsc_hg19 = read.table("/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/gene_coordinates/chrom_length/chrom_length_final_v1.txt", sep="\t", header=TRUE) #you cannot have window where no chromosome exists. This can lead to problems, for example in the calculation of the recombination rate, where a window can be discarded if no data points are close to the extremes. Therefore, a window with one end outside of the chromosome could be removed even if recombination data exists within the boundaries of the chromosome. 

#load the gap data to subtract gap length from the window length when coding density is calculated. 
#IMPORTANT!!! REVISE YOUR ARE USING THE LAST VERSION OF GAPS!!
gap_results_extracted_final = read.table('/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/gap_length_final_v3.txt', sep='\t', header=TRUE) #the number of coding bases has to be divided by the real length of bases inside the window. If you have gaps of no data inside the window, you do not know if these regions are coding or not. Therefore, you have to remove them when calculating the proportion of coding bases respect to the total of bases. You have to count only those bases for which you have data. 
#check that all the gene ids for which we have gaps are included in the gene list and exon data.
#gene list
!FALSE %in% c(gap_results_extracted_final$gene_id %in% all_genes_grch37_exon_filter_final$ensembl_gene_id)
!FALSE %in% c(all_genes_grch37_exon_filter_final$ensembl_gene_id %in% gap_results_extracted_final$gene_id)
#exon data
!FALSE %in% c(gap_results_extracted_final$gene_id %in% full_exon_data_filtered_final$ensembl_gene_id)
!FALSE %in% c(full_exon_data_filtered_final$ensembl_gene_id %in% gap_results_extracted_final$gene_id)


#VERY IMPORTANT!!! EVERY TIME you make changes in the window calculation, you have to run this code, then run the script of gaps to calculate the gaps inside each window and then run again this script to calculate the coding density with the gaps calculated in the new windows. 

#write the function
#selected_chr=1
#selected_id_gene="ENSG00000058453" #gen with gaps close.
#selected_id_gene="ENSG00000185220" #gen very close to the end of the chromosome 1
#selected_id_gene="ENSG00000186092" #gen very close to the start of the chromosome 1
genomic_coords_coding_density = function(selected_chr){ #each chromosome will be analyzed independently. It does not make sense to create windows between chromosomes, linkage and other factors that affect close regions act within chromosomes
	#from all_genes_grch37_exon_filter_final, select the rows of the selected chromosome and then get the gene id, selecting the unique cases
	unique_gene_ids_chr = unique(all_genes_grch37_exon_filter_final[which(all_genes_grch37_exon_filter_final$chromosome_name == selected_chr),]$ensembl_gene_id)

	#for each id gene
	final_positions = data.frame(chromosome_name=NA, hgnc_symbol=NA, gene_id=NA, test_rows_initial_datasets_1=NA, test_rows_initial_datasets_2=NA, test_gene_id=NA, gene_biotype=NA, transcript_id=NA,transcript_biotype=NA, exon_id=NA, test_gene_transcripts_biotype=NA, gene_start=NA, gene_end=NA, gene_length=NA, middle_point=NA, test_gene_length_center=NA, windows_check_1=NA, windows_check_2=NA, windows_check_3=NA, windows_check_4=NA, windows_check_5=NA, lower_end_window_50kb=NA, upper_end_window_50kb=NA, lower_end_window_100kb=NA, upper_end_window_100kb=NA, lower_end_window_200kb=NA, upper_end_window_200kb=NA, lower_end_window_500kb=NA, upper_end_window_500kb=NA, lower_end_window_1000kb=NA, upper_end_window_1000kb=NA, n_genes_50kb=NA, n_genes_100kb=NA, n_genes_200kb=NA, n_genes_500kb=NA, n_genes_1000kb=NA, check_n_genes_0=NA, check_n_genes_1=NA, check_n_genes_2=NA, check_n_genes_3=NA, check_n_genes_4=NA, check_coding_density_1=NA, check_coding_density_2=NA, check_coding_density_4=NA, check_coding_density_5=NA, check_coding_density_6=NA, check_coding_density_7=NA, test_all_ranges_included=NA, test_iranges=NA, test_start_end=NA, test_ranges_overlap=NA, test_ranges_overlap_2=NA, coding_density_50kb=NA, coding_density_100kb=NA, coding_density_200kb=NA, coding_density_500kb=NA, coding_density_1000kb=NA, test_position_gene_exons=NA, test_chr_name=NA, test_na_cds=NA)
	for(i in 1:length(unique_gene_ids_chr)){

		#select the [i] gene
		selected_id_gene = unique_gene_ids_chr[i] #I am going to comment the results for the gene SCYL3 (ENSG00000000457; http://grch37.ensembl.org/Homo_sapiens/Transcript/Exons?db=core;g=ENSG00000000457;r=1:169818772-169863093;t=ENST00000367771). This gene has all its transcripts in reverse sense
			#this is [i] = 1

		##########################################
		###### SELECT DATA OF THE [i] GENE #######
		##########################################

		#extract gene characteristics from the gene list
		gene_characteristics = all_genes_grch37_exon_filter_final[which(all_genes_grch37_exon_filter_final$ensembl_gene_id == selected_id_gene),]

		#from full_exon_data select those rows with exon data for the [i] gene
		exon_data = full_exon_data_filtered_final[which(full_exon_data_filtered_final$ensembl_gene_id == selected_id_gene),] #4 transcripts are included for SCYL3. In the webpage we have 5, but the last one is not protein coding, because of this we don´t have it.

		#reorder the rows of gene_characteristics to match exon data.
		gene_characteristics = gene_characteristics[match(paste(exon_data$ensembl_transcript_id, exon_data$ensembl_exon_id), paste(gene_characteristics$ensembl_transcript_id, gene_characteristics$ensembl_exon_id)),] #we match using both exon id and transcript id because the same exon id can be in different transcripts, thus we need two conditions for matching. The paste function create strings using the transcript id and the exon id, you can create these strings using start_end_coding_regions and exon_data, then use match to match the rows of exon data to those of start_end_coding_regions. See 'https://stackoverflow.com/questions/47404477/match-with-multiple-criteria-without-loop-in-r' for further details. 

		#remove those rows without coding sequence from exon data
		exon_data = exon_data[which(!is.na(exon_data$genomic_coding_start) & !is.na(exon_data$genomic_coding_end)),]

		#then we remove that rows from gene_characteristics, we select those rows of gene_characteristics that transcripts and exon id combinations included in exon_data. Bear in mind that the same exon ids can be in different transcripts
		gene_characteristics = gene_characteristics[which(paste(gene_characteristics$ensembl_transcript_id, gene_characteristics$ensembl_exon_id) %in% paste(exon_data$ensembl_transcript_id, exon_data$ensembl_exon_id)),]
		#check
		test_rows_initial_datasets_1 = gene_characteristics$ensembl_exon_id %in% exon_data$ensembl_exon_id & gene_characteristics$ensembl_transcript_id %in% exon_data$ensembl_transcript_id
		test_rows_initial_datasets_2 = exon_data$ensembl_exon_id %in% gene_characteristics$ensembl_exon_id & exon_data$ensembl_transcript_id %in% gene_characteristics$ensembl_transcript_id


		#######################################################
		###### EXTRACT CHROMOSOME, GENE SYMBOL, AND IDs #######
		#######################################################

		#extract the chromosome name
		#if the chromosome name matches with the chromosome is currently working the code
		if(all(selected_chr == gene_characteristics$chromosome_name)){

			#save the chromosome name
			chromosome_name = rep(unique(gene_characteristics$chromosome_name), nrow(exon_data))
		} else {

			#set an error
			chromosome_name = rep(NA,  nrow(exon_data))
		} #chromosome name 1 like in the webpage for SCYL3

		#extract the gene name
		hgnc_symbol = rep(unique(gene_characteristics$hgnc_symbol), nrow(exon_data)) #matches the data from the webpage for SCYL3

		#extract the id gene
		gene_id =  exon_data$ensembl_gene_id #matches the data from the webpage for SCYL3

		#check that the number of rows in each dataset (gene_characteristics and exon_data) for the [i] gene are the same
		test_gene_id = rep(nrow(gene_characteristics) == nrow(exon_data), nrow(exon_data))

		#extract the id transcript
		transcript_id =  exon_data$ensembl_transcript_id

		#extract the id exon
		exon_id =  exon_data$ensembl_exon_id #the same exon_id is repeated in different transcripts. I have checked in the webpage and it occurs the same. For example, ENSE00000789668 is included in three different transcripts of the same gene (SCYL3) and it has exactly the same sequence. You can see in the exon map exactly the same region for that exon in the three transcripts (is coding exon number 12 in the transcript ENST00000367772). Because of this, when we match rows between datasets, we cannot use only the exon id, but also the transcript id.



		###################################
		###### EXTRACT GENE BIOTYPE #######
		###################################

		#extract the gene biotype
		#if we only have 1 biotype of gene
		if(length(unique(exon_data$gene_biotype)) == 1 & length(unique(exon_data$transcript_biotype)) == 1){

			#save the biotype
			gene_biotype = exon_data$gene_biotype
			transcript_biotype = exon_data$transcript_biotype #both biotypes are 'protein_coding', so we have removed the last transcript for SCYL3, which is 'Processed transcript'

			#check that everything is ok with biotypes
			#if the gene
			if(unique(exon_data$gene_biotype) == 'protein_coding' & unique(exon_data$transcript_biotype) == 'protein_coding'){

				#everything seems to be ok
				test_gene_transcripts_biotype = rep(TRUE, nrow(exon_data))
			} else { #if not

				#we have a problem
				test_gene_transcripts_biotype = rep(FALSE, nrow(exon_data))
			}
		} else { #if not

			#we have a problem
			gene_biotype = rep(NA, nrow(exon_data))
			transcript_biotype = rep(NA, nrow(exon_data))			
			test_gene_transcripts_biotype = rep(NA, nrow(exon_data))
		}



		#####################################################################################################
		###### CALCULATE GENE LENGTH, MIDDLE POINT AND WINDOWS ACCORDING THE WHOLE REGION OF THE GENE #######
		#####################################################################################################

		#if the start and end position is unique for the whole gene, i.e., we only have one start and end for the whole gene
		if(length(unique(gene_characteristics$end_position)) == 1 & length(unique(gene_characteristics$start_position)) == 1){
		
			#save the gene start and end
			gene_start = gene_characteristics$start_position
			gene_end = gene_characteristics$end_position

			#calculate middle point and gen length
			#set the middle point calculating the mean of the start and stop positions
			middle_point = rep((unique(gene_characteristics$start_position) + unique(gene_characteristics$end_position))/2, nrow(exon_data)) #the length calculated with start and end of the webpage gives the same result for SCYL3 ((169863408+169818772)/2 = 169841090)

			#calculate the difference between start/end and adding 1 to calculate the length between them including both extremes
			gene_length = rep(unique(gene_characteristics$end_position) - unique(gene_characteristics$start_position) + 1, nrow(exon_data)) #the length calculated with start and end of the webpage gives the same result for SCYL3 (169863408-169818772 + 1 = 44637).
				#even if the strand is reversed, the start position occurs before the end position, i.e., the start position coordinate is smaller than the coordinate of the end position. The same goes for the start and end of the exons. The start coordinate is smaller than the end coordinate even if the strand is reverse. 
					#I have checked in SCYL3, which reverse strand: "https://grch37.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000000457;r=1:169818772-169863408".

			#check that the middle point and the gene length are correctly calculated
			#extract the range or values beginning in the start position and ending in the end position of the gene
			gene_range = unique(gene_characteristics$start_position):unique(gene_characteristics$end_position)
			#if gene length is equal to the length of the gene range and the distance from the middle point to end and start of the gene are the same
			if(unique(gene_length) == length(gene_range) & unique(middle_point) - gene_range[1] == gene_range[length(gene_range)] - unique(middle_point)){
				
				#everything seems perfet
				test_gene_length_center = TRUE
			} else {
				#if not, we have a problem
				test_gene_length_center = FALSE
			}

			
			## calculate windows
			#set the length of the windows: 50, 100, 200, 500 and 1000 kb
			window_length = c(50000, 100000, 200000, 500000, 1000000)

			#create an empty data.frame to save results
			windows_coordinates = data.frame(selected_length=NA, lower_end=NA, upper_end=NA)

			#for each width
			for(j in 1:length(window_length)){

				#select the [j] width
				selected_length = window_length[j]

				#calculate the half of the total length, which will be used to calculate both ends around the gene center
				selected_length_half = (selected_length/2) - 0.5 #we have to subtract 0.5 because we have to count the point in the middle. You have to let 0.5 at each side to have 'space' for the middle point. For example, you have the middle of a gene in 20, and we want a window of 10, if you do 20+5 and 20-5 you will get 15 and 25, 25-15+1 gives 11. You need to remove 0.5 at each side of the center to have exactly the window size you want. 20+4.5=24.5 and 20-4.5=15.5; 24.5-15.5+1=10. In addition, length(15.5:24.5)=10

				#calculate the end and start position of the [j] window
				lower_end = unique(middle_point) - selected_length_half
				upper_end = unique(middle_point) + selected_length_half
				
				#save the results
				windows_coordinates = rbind.data.frame(windows_coordinates, cbind.data.frame(selected_length, lower_end, upper_end))
			}
			#remove the first row with NA
			windows_coordinates = windows_coordinates[-1,]

			#check that the width of each window is adequate
			windows_check_1 = rep(!FALSE %in% c(windows_coordinates$upper_end - windows_coordinates$lower_end + 1 == windows_coordinates$selected_length), nrow(exon_data)) #we calculate the complete length between the upper and lower end, because of this we sum 1, to include both extremes of the interval. We then check that the length of each interval correspond with the selected length used for calculating this interval.

			#check that the difference between each windows size for the lower and the upper extremes matches those differences in general of width size
			check_lower_end=NULL
			check_upper_end=NULL
			for(j in 1:(nrow(windows_coordinates)-1)){ #for each row of the dataset with the windows coordinate... we avoid the last row because there is no additional row to check differences
				
				#select the [j] and [j+1] rows
				selected_row_1 = windows_coordinates[j,]
				selected_row_2 = windows_coordinates[j+1,]

				#check that the lower end is correct
				check_lower_end = append(check_lower_end, selected_row_1$lower_end - selected_row_2$lower_end == (selected_row_2$selected_length - selected_row_1$selected_length)/2) #the difference in length between windows has to be divided by 2, because that difference is divided between both sides of the middle gene. For example, if you have 20 as middle gene, the lower end of a 10 size window would be 20-4.5=15.5, and for a 20 size window would be 20-9.5=10.5. The total difference between the windows is 10 (20-10=10), but the difference at each side of between the center is 5 (9.5-4.5=5)
					#we put selected_row_1$lower_end before the selected_row_2 because the lower end decrees with bigger window lengths, so it would give negative values if you put selected_row_2 first 

				#check that the upper end is correct
				check_upper_end = append(check_upper_end, selected_row_2$upper_end - selected_row_1$upper_end == (selected_row_2$selected_length - selected_row_1$selected_length)/2) #the difference in length between windows has to be divided by 2, because that difference is divided between both sides of the middle gene. For example, if you have 20 as middle gene, the upper end of a 10 window would be 20-4.5=15.5, and for a 20 window would be 20-9.5=10.5. The total difference between the windows is 10 (20-10=10), but the difference at each side of the center is 5 (9.5-4.5=5)
					#here we put the upper end of selected row 2 before, because the upper end is increasing with increased window size
			}

			#save the checks
			windows_check_2 = rep(!FALSE %in% c(check_upper_end), nrow(exon_data))
			windows_check_3 = rep(!FALSE %in% c(check_lower_end), nrow(exon_data))


			## remove decimals
			#after we have checked that the windows are properly calculated, we will floor both ends, in that way we maintain the size of the window we want. The window is not exactly exactly centered in the gene, there is a difference of 1 base if decimals exist, but it is only one base. This is not relevant for windows of 50000 bases or more. 
			windows_coordinates$lower_end = floor(windows_coordinates$lower_end)
			windows_coordinates$upper_end = floor(windows_coordinates$upper_end) #we have to floor both ends, if we floor one and apply ceiling to another, we will increase the size of the window. We want to remain the exact size we want, even if it is not exactly centered in the gene. For example, floor(9.5) would be 9 and ceiling(15.5) would be 16, so we are increasing the size of the window (from 15.5-9.5+1=7 to 16-9+1=8). If we do 15-9+1 we get 7.

			#RESPECT TO THE MIDDLE POSITION: we left the middle position with decimals to have the original middle position used to calculate the lower and the upper ends

			#final check that the window lengths matches what we expect
			windows_check_4 = !FALSE %in% c(windows_coordinates$upper_end - windows_coordinates$lower_end + 1 == windows_coordinates$selected_length) #we want the complete length of the window so we have to sum 1 to include both extremes, if not as the lower extreme is included in both lower and upper_end, we would left out one extreme.
		

			##check if the window surpass the limits of the chromosome
			#extract the length of the selected chromosome
			end_chromosome = chrom_length_ucsc_hg19[which(chrom_length_ucsc_hg19$chromosome == paste("chr", selected_chr, sep="")), which(colnames(chrom_length_ucsc_hg19) == "length_bp")]

			#if the any of the window ends surpass the chromosome limits: the lower end of any window is lower than 1 and hence negative OR the upper end of any window is higher than the length of the chromosome.
			if( TRUE %in% c(windows_coordinates$lower_end < 1) | TRUE %in% c(windows_coordinates$upper_end > end_chromosome) ){

				#if the lower end of any window is lower than 1 and hence negative
				if(TRUE %in% c(windows_coordinates$lower_end < 1)){

					#we set the window coordinates as NA
					windows_coordinates[which(windows_coordinates$lower_end < 1), c("lower_end", "upper_end")] <- NA #we have to remove them instead of trimming, because if you trim, you could have different windows with the same size, and we do not want that. We will have a little bit more of smaller windows, but this should not a problem because this is happening for around 400 genes.			
				}

				#if the upper end of any window is higher than the length of the chromosome.
				if(TRUE %in% c(windows_coordinates$upper_end > end_chromosome)){

					#we set the window coordinates as NA
					windows_coordinates[which(windows_coordinates$upper_end > end_chromosome), c("lower_end", "upper_end")] <- NA #we have to remove them instead of trimming, because if you trim, you could have different windows with the same size, and we do not want that. We will have a little bit more of smaller windows, but this should not a problem because this is happening for around 400 genes.			
				}
			}

			#check that no window surpass the chromosome limits
			windows_check_5 = !TRUE %in% c(windows_coordinates$lower_end < 1) & !TRUE %in% c(windows_coordinates$upper_end > end_chromosome) 
				#no TRUE should exist because no lower_end should be lower than 1 AND should exist because no upper_end should be higher than the length of the chromosome. 
				#you can have NAs because the window is not calculated, but NOT TRUE. TRUE would mean that the window surpass the chromosome limits.


			##save the windows
			#50kb
			lower_end_window_50kb = windows_coordinates[which(windows_coordinates$selected_length == 50000),]$lower_end
			upper_end_window_50kb = windows_coordinates[which(windows_coordinates$selected_length == 50000),]$upper_end

			#100kb
			lower_end_window_100kb = windows_coordinates[which(windows_coordinates$selected_length == 100000),]$lower_end
			upper_end_window_100kb = windows_coordinates[which(windows_coordinates$selected_length == 100000),]$upper_end

			#200kb
			lower_end_window_200kb = windows_coordinates[which(windows_coordinates$selected_length == 200000),]$lower_end
			upper_end_window_200kb = windows_coordinates[which(windows_coordinates$selected_length == 200000),]$upper_end

			#500kb
			lower_end_window_500kb = windows_coordinates[which(windows_coordinates$selected_length == 500000),]$lower_end
			upper_end_window_500kb = windows_coordinates[which(windows_coordinates$selected_length == 500000),]$upper_end

			#1000kb
			lower_end_window_1000kb = windows_coordinates[which(windows_coordinates$selected_length == 1000000),]$lower_end
			upper_end_window_1000kb = windows_coordinates[which(windows_coordinates$selected_length == 1000000),]$upper_end
		} else { #if we have different starts or ends, set NA

			#set NA
			gene_start = rep(NA, nrow(exon_data))
			gene_end = rep(NA, nrow(exon_data))
			middle_point = rep(NA, nrow(exon_data))
			gene_length = rep(NA, nrow(exon_data))
			test_gene_length_center = rep(NA, nrow(exon_data))
			windows_check_1 = rep(NA, nrow(exon_data))
			windows_check_2 = rep(NA, nrow(exon_data))
			windows_check_3 = rep(NA, nrow(exon_data))
			windows_check_4 = rep(NA, nrow(exon_data))
			windows_check_5 = rep(NA, nrow(exon_data))		
			lower_end_window_50kb = rep(NA, nrow(exon_data))
			upper_end_window_50kb = rep(NA, nrow(exon_data))
			lower_end_window_100kb = rep(NA, nrow(exon_data))
			upper_end_window_100kb = rep(NA, nrow(exon_data))
			lower_end_window_200kb = rep(NA, nrow(exon_data))
			upper_end_window_200kb = rep(NA, nrow(exon_data))
			lower_end_window_500kb = rep(NA, nrow(exon_data))
			upper_end_window_500kb = rep(NA, nrow(exon_data))
			lower_end_window_1000kb = rep(NA, nrow(exon_data))
			upper_end_window_1000kb = rep(NA, nrow(exon_data))
		}



		####################################
		###### CALCULATE GENE NUMBER #######
		####################################

		#extract the gene_characteristics_chromosome data for the chromosome (chromosome_name) to get all genes that are included in the window only for the selected chromosome. Note that the same position is in different chromosomes, so we could make an error here
		subset_gene_characteristics_chromosome = all_genes_grch37_exon_filter_final[which(all_genes_grch37_exon_filter_final$chromosome_name==unique(chromosome_name)),]
		
		#remove the gene ids not included in the corresponding chromosome
		subset_gene_characteristics_chromosome$ensembl_gene_id <- droplevels(subset_gene_characteristics_chromosome$ensembl_gene_id) #we remove the levels not used, i.e., genes not included in the corresponding chromosome, because in previous versions we used dplyr to check whether the sequence of each gene is included in the window. This was performed per gene applying the inrange function in each group of rows with the same gene id. Dplyr search for all levels of gene_id even if the gene id not included. We have to removed these unused levels.

		#open an empty data.frame to save the results 
		n_genes_windows = data.frame(selected_length=NA, lower_end=NA, upper_end=NA, n_genes=NA, check_n_genes_0=NA, check_n_genes_1=NA, check_n_genes_2=NA, check_n_genes_3=NA, check_n_genes_4=NA)

		#for each window
		for(j in 1:nrow(windows_coordinates)){

			#select the [j] window
			selected_window = windows_coordinates[j,]

			#we do not have NA in any of the window limits we perform the calculations
			if(!is.na(selected_window$lower_end) & !is.na(selected_window$upper_end)){

				#select those genes whose start OR end is equal/higher than the start of the window AND equal/smaller than the end of the window. 
				genes_inside_window = subset_gene_characteristics_chromosome[which(subset_gene_characteristics_chromosome$start_position >= selected_window$lower_end & subset_gene_characteristics_chromosome$start_position <= selected_window$upper_end | subset_gene_characteristics_chromosome$end_position >= selected_window$lower_end & subset_gene_characteristics_chromosome$end_position <= selected_window$upper_end | subset_gene_characteristics_chromosome$start_position < selected_window$lower_end & subset_gene_characteristics_chromosome$end_position > selected_window$upper_end),] #in that way we can include all the genes within the window, even if only a part of them (end or start) is included. The first two conditions select those genes whose start is within the window but the end could be included or not, whilst the next two conditions select genes that have their end inside the window but the start could be or not included. See figure 18 for further details.
					#we add an additional condition, which is to include genes with a start position lower than the lower end and a end position higher than the upper end. This is made for genes that are too big, for example C1orf112, when this gene is the center, the range of 50 kb will be smaller than the whole gene, so the start and the end are outside of the range, but because the windows is in the middle of the windows sides. I have checked that the first window when C1orf112 is the central gene does not include C1orf112 if the third condition is not included. C1orf112 starts before the end of the 50kb window and ends after the end of that window. the problem is solved adding the third condition.
					#NOTE: We should not have any problem with the reverse strand, because gen start/end (and exon start/end and genomic start/end) follow the forward values. For example, in the first transcript (ENST00000367771) of SCYL3 (ENSG00000000457), the last coding exon according to cds_start/end and the webpage, has the lowest values of exon_chrom_start and end, the same for genmomic_codin_start and end gene start/end. Therefore, start of gene, exon and coding region follow the coordinates of the positive strand.
					#FOR CODING DENSITY WOULD BE THE SAME, BUT USING EXON DATA!!
				
				#extract the genes outside the window to make a check
				genes_outside_window = subset_gene_characteristics_chromosome[which(!subset_gene_characteristics_chromosome$ensembl_gene_id %in% genes_inside_window$ensembl_gene_id),] #we don´t use the opposite selection with higher-lower etc... because some genes can be part outside and part inside of the gene window, they will be considered out and in. We directly select those genes not included inside the window. 
				check_n_genes_0 = nrow(genes_inside_window) + nrow(genes_outside_window) == nrow(subset_gene_characteristics_chromosome) #same number.

				#extract the number inside the window, whcih are unique cases of gene id
				n_genes = length(unique(genes_inside_window$ensembl_gene_id)) #we are considering any gene with end or start inside the window even the complete gene is not included in the window

				#checks n_genes
				#we only make the check if case with no hgnc symbol are present. For example, in the windows of SCYL3, we have 40 gene ids, but 37 hgnc symbols. This difference is caused because 4 genes has no hgnc symbol, hgnc_symbol variable is empty. Therefore, we have 36 hgnc real symbols, them a value of '' for the first gene without hgnc symbol (37) and the three more ids without symbol, summing up to 40.
				if(!'' %in% genes_inside_window$hgnc_symbol){
					check_n_genes_1 = length(unique(genes_inside_window$hgnc_symbol)) == n_genes #check that the number of genes matches the number of unique hgnc symbols
						#NOTE that we cannot make a check with the exon data dataset because in full_exon_data_filtered_final, non coding transcripts are already removed. So the first/last exon can be not included if it is non-coding and hence the corresponding gene would not be included, whilst it would be included considering the full gene length (gene start/end)
				} else {

					check_n_genes_1 = NA
				}

				#other check
				check_n_genes_2 = all(genes_inside_window$start_position - selected_window$lower_end >= 0 & selected_window$upper_end - genes_inside_window$start_position >= 0 | genes_inside_window$end_position - selected_window$lower_end >= 0 & selected_window$upper_end - genes_inside_window$end_position >= 0 | genes_inside_window$start_position - selected_window$lower_end < 0 & selected_window$upper_end - genes_inside_window$end_position < 0) #check that within the genes selected, the start position is equal or higher to the lower end of the window and AND equal or lower to the upper end OR the end position is equal or higher than the lower end AND equal or lower to the upper end. We check this making a rest between the start and end positions and the lower/upper ends: 
					#The gene start is inside the window if these two conditions does not occur:
						#a) if the difference between gen start position and lower end is negative, then the lower end is higher than the start position, i.e., the gene begins before the window does it; 
						#b) if the the difference between the upper end and the gene start position is negative, then the start is higher than the end, and hence the gene begins after the windows ends; 
					#The gene end is inside the window if these two conditions does not occur:
						#c) if the difference between the end of the gene and the lower end of the window is negative, then the lower end is higher than the end of the gene, and hence the gene ends after the window starts; 
						#d) if the difference between the upper end and the end of the gene is negative, then the end position of the gene is higher and then that gene ends after the window does it;
					#The gene starts before the start of the window and the gene ends after the window is finished. Therefore, even the start/end of the gene is not included in the window, the whole window is occupied by the gene.
						#f) if the difference between the start position of the gene and the  lower end of the window is negative, then the lower end is higher that the gene start and hence the gene starts before the window does it.
						#g) if the difference between the upper end of the window and the end position of the gene is negative, then the end of the gene is higher than the end of the window and hence the gene ends after the window does it.
					#ALL genes have to satisfy the following: 
						#That the start is between the upper and lower extremes, i.e., it is equal or higher than the lower limit and equal or lower than the upper limit
							#OR
						#That the end is between the upper and lower extremes, i.e., it is equal or higher than the lower limit and equal or lower than the upper limit. 
							#OR
						#The start occurs before the window and the end after the window. Therefore, the exon occupy the whole length of the window.

				#check that there is no gene outside the window that satisfy the conditions used in check_n_genes_2. Genes with part outside and inside has been removed from genes_outside_window
				check_n_genes_3_v1 = genes_outside_window$start_position - selected_window$lower_end >= 0 & selected_window$upper_end - genes_outside_window$start_position >= 0 | genes_outside_window$end_position - selected_window$lower_end >= 0 & selected_window$upper_end - genes_outside_window$end_position >= 0 | genes_outside_window$start_position - selected_window$lower_end < 0 & selected_window$upper_end - genes_outside_window$end_position < 0
				#check that all is FALSE, i.e., not TRUE is included
				check_n_genes_3 = ifelse(!TRUE %in% check_n_genes_3_v1 & all(!is.na(check_n_genes_3_v1)), TRUE, FALSE) #if all checks are FALSE and with have no NA, give me TRUE


				##Final check
				#we will calculate the number of genes inside the [j] window using genomic ranges

				#create the reference range using the window start and end
				window_range_check_gene_number = IRanges(start=selected_window$lower_end, end=selected_window$upper_end) #create a IRange object with the start and end of the [j] window

				#convert to a GRanges object. We need a GRanges object to select those exons in the the subject GRange file that included in the reference range. 
				window_range_check_gene_number_gr = GRanges(seqnames=unique(chromosome_name), ranges=window_range_check_gene_number, strand = '*') #seqnames are the names of the chromosome names. This is very important, because if we select as seq names the exons ids, it consider each exon as independent and do not search for overlapping ranges within all exons; ranges are the start and end of each sequence, and are created with the function IRanges. I have checked that when an exon occupy the whole window, if you use exon id as sequence name, the complete length of the range is not calculated, I have to use the chromosome name. The same occurs when you try to get all the ranges without overlapping using disjoin, only are considered the ranges of the same seqname; strand indicate the sense of the sequence. We have the information of the strand in the strand variable, but as I have revised previously, genomic start/end have the same sense independently of the strand. Just in case, i will use *. In any case, I have seen no changes if this modified in the exon data (I have checked the no impact of strand in this exact example for gap length).
					#the information was obtained from the script of the coding density (see below).

				#remove the duplicate rows for the same gene
				subset_gene_characteristics_chromosome_no_duplicated = subset_gene_characteristics_chromosome[which(!duplicated(subset_gene_characteristics_chromosome$ensembl_gene_id)),] #if you have several rows with the same gene, IRanges will consider them as different sequences.
				#check
				nrow(subset_gene_characteristics_chromosome_no_duplicated) == length(unique(subset_gene_characteristics_chromosome$ensembl_gene_id))

				#select the gene ranges
				gene_ranges = IRanges(start=subset_gene_characteristics_chromosome_no_duplicated$start_position, end=subset_gene_characteristics_chromosome_no_duplicated$end_position) #create a IRange object with the start and end of genes in the selected chromosome. 

				#convert the IRange file into a genomic range file
				gene_ranges_gr = GRanges(seqnames=unique(chromosome_name), ranges=gene_ranges, strand = '*') #sequnames are the names of the chromosome names. This is very important, because if we select as seq names de exons ids, it consider each exon as independent and do not search for overlapping ranges within all exons; ranges are the start and end of each sequence, and are created with the function IRanges. I have checked that when an exon occupy the whole window, if you use exon id as sequence name, the complete length of the range is not calculated, I have to use the chromosome name. The same occurs when you try to get all the ranges without overlapping using disjoin, only are considered the ranges of the same seqname; strand indicate the sense of the sequence. We have the information of the strand in the strand variable, but as I have revised previously, genomic start/end have the same sense independently of the strand. Just in case, i will use *. In any case, I have seen no changes if this modified in the exon data (I have checked the no impact of strand in this exact example for gap length).
						#this explanation is taken from gene_coordinates_v8.r. But for the 1000kb window of "ENSG00000058453" (CROCC) I have checked that putting the strand of the all genes ("subset_gene_characteristics_chromosome_no_duplicated") does not change anything. These are genes with positive and negative strand, but no change is produced.

				#we do not remove overlapping between the tested ranges because we want to count every gen that is included within the window. If you remove overlapping regions, for a given region you lost the different genes that are present there and get only 1 count. We do not want that. 

				#find what of the tested ranges and are overlapped with the reference range
				hits_gene_number = findOverlaps(window_range_check_gene_number_gr, gene_ranges_gr)

				#extract those tested ranges that hit and their number
				n_genes_2 = length(gene_ranges_gr[subjectHits(hits_gene_number)]@ranges)
					#subjectHits extracts what of the tested ranges are overlapped with the reference ranges.

				#check if the result is the same than the original gene number
				check_n_genes_4 = n_genes == n_genes_2
			} else { #if you have NA for the window limits

				#Set NA for everything, except selected window
				n_genes = NA
				check_n_genes_0 = NA
				check_n_genes_1 = NA
				check_n_genes_2 = NA
				check_n_genes_3 = NA
				check_n_genes_4 = NA
			}
			
			#save the results in a data.frame
			n_genes_windows = rbind.data.frame(n_genes_windows, cbind.data.frame(selected_window, n_genes, check_n_genes_0, check_n_genes_1, check_n_genes_2, check_n_genes_3, check_n_genes_4))
		}
		#remove first row with NAs
		n_genes_windows = n_genes_windows[-1,] #I have checked for SCYL3 (ENSG00000000457) the first two windows. The first window (50kb) includes two genes (SCYL3 and C1orf112), whilst the second one also includes KIFAP3. I have check the map around SCYL3 (http://grch37.ensembl.org/Homo_sapiens/Location/View?db=core;g=ENSG00000000457;r=1:169817880-169864300), and i have seen two genes closer to SCYL3 than C1orf112, which are METTL18 and SELL. However, I have checked that the end of these genes (169680839 and 169764107) occur before the start of the two first windows (169816090.5 and 169791090.5). In contrast, C1orf112 starts very far away from SCYL3, but its end (169823221) reached the start of these windows. In the next window, which is wider and hence starts before (169741090.5), METTL18 is included. The next windows (500kb) already include SELE, SELP and SEL. Finally, the widest window (100 kb) also includes BLZF1, CCDC181, SLC19A2, F5, METTL11B. In that way, we have included all the coding genes you can see in the window. If you scroll to both sides, you can see as no more coding genes are present between the boundaries of the last window (169341090.5 - 170341089.5). The rest are pseudogenes, RNa genes and processed transcripts.

		#save the number of genes per each window
		n_genes_50kb = rep(n_genes_windows[which(n_genes_windows$selected_length == 50000),]$n_genes, nrow(exon_data))
		n_genes_100kb = rep(n_genes_windows[which(n_genes_windows$selected_length == 100000),]$n_genes, nrow(exon_data))
		n_genes_200kb = rep(n_genes_windows[which(n_genes_windows$selected_length == 200000),]$n_genes, nrow(exon_data))
		n_genes_500kb = rep(n_genes_windows[which(n_genes_windows$selected_length == 500000),]$n_genes, nrow(exon_data))
		n_genes_1000kb = rep(n_genes_windows[which(n_genes_windows$selected_length == 1000000),]$n_genes, nrow(exon_data))


		##summarize all the gene_number_checks
		#create a vector with the check to be summarized
		gene_number_checks_to_summarize = c("check_n_genes_0","check_n_genes_1","check_n_genes_2","check_n_genes_3","check_n_genes_4")

		#for each check to be summarized
		for(j in 1:length(gene_number_checks_to_summarize)){

			#select the [j] check to summarize
			selected_gene_number_check = gene_number_checks_to_summarize[j]

			#extract the corresponding column
			selected_column_gene_number_check = n_genes_windows[,which(colnames(n_genes_windows) == selected_gene_number_check)]	

			#if no FALSE is present in the check
			if(!FALSE %in% selected_column_gene_number_check){

				#if there is no FALSE in is.na() and hence all cases are NA
				if(!FALSE %in% is.na(selected_column_gene_number_check)){

					#set the check as TRUE
					summary_gene_number_check = rep(NA, nrow(exon_data))
				} else { #if not, and hence not all cases are NA
					
					#if you have NAs and TRUEs
					if(TRUE %in% is.na(selected_column_gene_number_check) & TRUE %in% selected_column_gene_number_check){
						
						#set the check as TRUE/NA
						summary_gene_number_check = rep("TRUE/NA", nrow(exon_data))
					} else { #if not, we dot not have any NA

						#set the check as TRUE
						summary_gene_number_check = rep(TRUE, nrow(exon_data))
					}
				}
			} else { #if we have FALSE

				summary_gene_number_check = rep(FALSE, nrow(exon_data))
			}

			#assign the value of the summary check to the corresponding variable.
			assign(selected_gene_number_check, summary_gene_number_check) #see second response in "https://stackoverflow.com/questions/28909191/treat-string-as-object-name-in-a-loop-in-r" for further details about assign		
		}	



		#######################################
		###### CALCULATE CODING DENSITY #######
		#######################################

		#extract the exon data data for the chromosome (chromosome_name) to get all exons that are included in the window only for the selected chromosome. Note that the same position is in different chromosomes, so we could make an error here.
		subset_exon_data_chromosome = full_exon_data_filtered_final[which(full_exon_data_filtered_final$chromosome_name==unique(chromosome_name)),]
		
		#open an empty data.frame to save the results 
		coding_density_windows = data.frame(selected_length=NA, lower_end=NA, upper_end=NA, check_coding_density_1=NA, check_coding_density_2=NA, check_coding_density_4=NA, check_coding_density_5=NA, check_coding_density_6=NA, check_coding_density_7=NA, test_all_ranges_included=NA, test_iranges=NA, test_start_end=NA, test_ranges_overlap=NA, test_ranges_overlap_2=NA, coding_density=NA) #IMPORTANT: the check_coding_density_3 was in version 6, but in 7 was removed because it is very slow. I have maintained the order of the checks to remember that check 3 was that removed.

		#for each window
		for(j in 1:nrow(windows_coordinates)){

			#select the [j] window
			selected_window = windows_coordinates[j,]

			#we do not have NA in any of the window limits we perform the calculations. Few lines below there is a ifelse for separating cases with exons inside the window than those without exons. That ifelse is different from this one, because you have window but no exons, here we do not have window. 
			if(!is.na(selected_window$lower_end) & !is.na(selected_window$upper_end)){

				#select the gaps for the [i] gene and the [j] window
				selected_gap = gap_results_extracted_final[which(gap_results_extracted_final$gene_id == selected_id_gene), which( colnames(gap_results_extracted_final) == paste("length_gaps_", (selected_window$selected_length / 1000), "kb", sep="")) ,] #select the gaps (row) for the [i] gene. Select the gap (column) for the [k] window. We divided the length of the window by 1000 to have the length in kb and match the colnames in gap_results_extracted_final. 

				#select those exons whose start of the coding sequence OR its end is equal/higher than the start of the window AND equal/smaller than the end of the window. 
				exons_inside_window = subset_exon_data_chromosome[which(subset_exon_data_chromosome$genomic_coding_start >= selected_window$lower_end & subset_exon_data_chromosome$genomic_coding_start <= selected_window$upper_end | subset_exon_data_chromosome$genomic_coding_end >= selected_window$lower_end & subset_exon_data_chromosome$genomic_coding_end <= selected_window$upper_end | subset_exon_data_chromosome$genomic_coding_start < selected_window$lower_end & subset_exon_data_chromosome$genomic_coding_end > selected_window$upper_end),]
					#We select all exons that satisfy the following conditions:
						#Genomic start is equal/higher than the lower limit of the window AND equal/lower than the upper limit. Therefore, it is included between the window.
						#Genomic end is equal/higher than the lower limit of the window AND equal/lower than the upper limit. Therefore, it is included between the window.
						#Genomic start is lower than the lower limit AND higher than the upper limit. Therefore, it is included between the window. 
					#In that way we can include all the genes within the window, even if only a part of them (end or start) is included. The first two conditions we include those exons whose genomic start is within the window but their end could not be, whilst the next two conditions select genes that have their end inside the window but the start could be outside. See figure 19 for further details.
					#We add an additional condition, which is to include exons with a genomic start position lower than the lower end of the window and a genomic end position higher than the upper end of the window. This is made just in case a gene could have very big exon, bigger than the window centered in that gene. I do not know right know about this case, but just in case. In the case of big genes I have the case of C1orf112....
					#NOTE: We should not have any problem with the reverse strand, because gen start/end (and exon start/end and genomic start/end) follow the forward values. For example, in the first transcript (ENST00000367771) of SCYL3 (ENSG00000000457), the last coding exon according to cds_start/end and the webpage, has the lowest values of exon_chrom_start and end, the same for genmomic_codin_start and end gene start/end. Therefore, start of gene, exon and coding region follow the coordinates of the positive strand.
					
					#see figure 19 for further details

					#we use genomic start and end for getting ALL exons within the window. The same exon can be select several times, as the same exon id can be in different transcripts, bu this should not be a problem as we will calculate the coding sequence inside the window with not overlapped ranges (with genomic ranges), so two equal exons would share the same area, but that area will not be included two times. Even I have seen the same region shared by two different genes, like the beginning of SCYL3 and the end of C1orf112. Again, if the overlap is calculated, this should not be a problem.

				#if we have exons inside the window
				if(nrow(exons_inside_window) > 0){ #It is possible that no coding exon exits inside the window. For example when RAB27B (ENSG00000041353: chromosome 18, i=2) is the center, there is no other gene inside the 50kb window. Moreover, that gene has a very big intron in the middle, leading that the 50kb window has no coding exon inside: http://grch37.ensembl.org/Homo_sapiens/Location/View?db=core;g=ENSG00000041353;r=18:52381538-52566300. In the case of gene number, we do not need this, because if you center the window in the middle of a gene, you are for sure in the middle of a gene, so that counts for 1, even if the gene is very very small.

					#extract the genes outside the window to make a check
					exons_outside_window = subset_exon_data_chromosome[which(!subset_exon_data_chromosome$ensembl_exon_id %in% exons_inside_window$ensembl_exon_id),] #we don´t use the opposite selection with higher-lower etc... because some exons can be part outside and part inside of the window, they will be considered out and in. We directly select those exons not included inside the window. 
					nrow(exons_inside_window) + nrow(exons_outside_window) == nrow(subset_exon_data_chromosome) #same number.

					#other check_coding_density_1
					check_coding_density_1 = all(exons_inside_window$genomic_coding_start - selected_window$lower_end >= 0 & selected_window$upper_end - exons_inside_window$genomic_coding_start >= 0 | exons_inside_window$genomic_coding_end - selected_window$lower_end >= 0 & selected_window$upper_end - exons_inside_window$genomic_coding_end >= 0 | exons_inside_window$genomic_coding_start - selected_window$lower_end < 0 & selected_window$upper_end - exons_inside_window$genomic_coding_end < 0) #check that within the exons selected, the genomic start position is equal or higher to the lower end of the window and AND equal or lower to the upper end OR the genomic end position is equal or higher than the lower end AND equal or lower to the upper end. We check this making a rest between the genomic start and end positions and the lower/upper ends: 
						#The genomic start is inside the window if these two conditions does not occur:
							#a) if the difference between genomic start position and lower end is negative, then the lower end is higher than the start position, i.e., the coding region begins before the window does it; 
							#b) if the the difference between the upper end and the gene start position is negative, then the start is higher than the end of the window, and hence the gene begins after the windows ends; 
						#The end is outside the window if these two conditions does not occur:
							#c) if the difference between the end of the coding region of the exon and the lower end of the window is negative, then the lower end is higher than the end of the coding region, and hence this region ends after the window starts; 
							#d) if the difference between the upper end and the end of the genomic region is negative, then the end position of the genomic region is higher and then that region ends after the window does it;
						#The coding region starts before the start of the window and that region ends after the window is finished. Therefore, even the start/end of the gene is not included in the window, the whole window is occupied by the gene.
							#f) if the difference between the genomic start position of the exon and the  lower end of the window is negative, then the lower end is higher that the genomic start and hence that coding region starts before the window does it.
							#g) if the difference between the upper end of the window and the genomic end position of the exon is negative, then the end of the genomic region is higher than the end of the window and hence that region ends after the window does it.
						#ALL exons have to satisfy the following: 
							#That the genomic coding start is between the upper and lower extremes, i.e., it is equal or higher than the lower limit and equal or lower than the upper limit
								#OR
							#That the genomic coding end is between the upper and lower extremes, i.e., it is equal or higher than the lower limit and equal or lower than the upper limit. 
								#OR
							#The genomic starts occurs before the window and the genomic end after the window. Therefore, the exon occupy the whole length of the window.

					#check that there is no gene outside the window that satisfy the conditions used in check_coding_density_1. Genes with part outside and inside has been removed from exons_outside_window
					check_coding_density_2_v1 = exons_outside_window$genomic_coding_start - selected_window$lower_end >= 0 & selected_window$upper_end - exons_outside_window$genomic_coding_start >= 0 | exons_outside_window$genomic_coding_end - selected_window$lower_end >= 0 & selected_window$upper_end - exons_outside_window$genomic_coding_end >= 0 | exons_outside_window$genomic_coding_start - selected_window$lower_end < 0 & selected_window$upper_end - exons_outside_window$genomic_coding_end < 0
					#check that all is FALSE, i.e., not TRUE is included
					check_coding_density_2 = ifelse(!TRUE %in% check_coding_density_2_v1, TRUE, FALSE) #if all checks are FALSE give me TRUE. We remove the filter of the NAs respect to the code of gene number, because we can have exons without coding sequence (UTR tails). Even if some of these exons should be inside the window, they are not coding, so we are not interested in them for calculating coding density. In the case of gene number, all cases have a gene id, so NAs were not acceptable, and hence we have to check that they were not present.


					## from exons with part of the coding region outside and inside of the window, we remove the part outside

					#copy the exons inside the window to do some operations (remove parts outside of the window)
					exons_inside_window_copy <- exons_inside_window

					#In case you want to check this selection work, I have created code for generating exons that satisfy these conditions, i.e., that are in the frontier of the window
						#the genomic start is 100 bases before the start of the window
							#exons_inside_window_copy[3,]$genomic_coding_start <- selected_window$lower_end - 100
					
						#NOT RUN. the genomic start is 100 bases after the end of the window. We DO NOT use this because this scenario should not occur. If the start occurs after the window, the whole exon is outside the window and should be removed in the previous filter
							##exons_inside_window_copy[7,]$genomic_coding_start <- selected_window$upper_end + 100
					
						#the genomic end is 100 bases after the end of the window
							#exons_inside_window_copy[14,]$genomic_coding_end <- selected_window$upper_end + 100
					
						#NOT RUN. the genomic end is 100 bases before the start of the window. We DO NOT use this because this scenario should not occur. If the end occurs before the window, the whole exon is outside the window and should be removed in the previous filter
							##exons_inside_window_copy[9,]$genomic_coding_end <- selected_window$lower_end - 100

						#the genomic start is 100 bases before the start of the window AND the genomic end is 100 bases after the end of the window
							#exons_inside_window_copy[17,]$genomic_coding_start <- selected_window$lower_end - 100
							#exons_inside_window_copy[17,]$genomic_coding_end <- selected_window$upper_end + 100

					#select those exons whose genomic coding start occurs before the start of the window
					exons_inside_window_start_out = which(exons_inside_window_copy$genomic_coding_start < selected_window$lower_end & exons_inside_window_copy$genomic_coding_end >= selected_window$lower_end & exons_inside_window_copy$genomic_coding_end <= selected_window$upper_end) #we select those exons whose genomic start occurs before the start of the window but their genomic end is included in the window. In that way, we removed those with start before and end after. Those will be included in exons_inside_window_start_end_out.

					#select those exons whose genomic coding end occurs after the end of the window
					exons_inside_window_end_out = which(exons_inside_window_copy$genomic_coding_end > selected_window$upper_end & exons_inside_window_copy$genomic_coding_start >= selected_window$lower_end & exons_inside_window_copy$genomic_coding_start <= selected_window$upper_end) #we select those exons whose genomic end occurs after the end of the window but their genomic start is included in the window. In that way, we removed those with start before and end after. Those will be included in exons_inside_window_start_end_out.

					#select those exons whose genomic coding start occurs before the start of the window and genomic coding end occurs after the end of the window
					exons_inside_window_start_end_out = which(exons_inside_window_copy$genomic_coding_start < selected_window$lower_end & exons_inside_window_copy$genomic_coding_end > selected_window$upper_end)

					#if we have exons with the start before the beginning of the window
					#open check v4
					check_coding_density_4 = NULL
					if(length(exons_inside_window_start_out)>0){
				
						##for those exons with the start before the window but the end is inside the window, we set the start coding region at the start of the window, while the end of the coding region remains without change, as it is being included in the window.
						exons_inside_window_copy[exons_inside_window_start_out,]$genomic_coding_start <- selected_window$lower_end
					
						#check
						check_coding_density_4 = append(check_coding_density_4, exons_inside_window_copy[exons_inside_window_start_out,]$genomic_coding_start == selected_window$lower_end)
					}

					#if we have exons with the end after the beginning of the window
					if(length(exons_inside_window_end_out)>0){
					
						##for those exons with the end after the window but the start is inside the window, we set the end of the coding region at the end of the window, while the start of the coding region remains without change, as it is being included in the window.
						exons_inside_window_copy[exons_inside_window_end_out,]$genomic_coding_end <- selected_window$upper_end
					
						#check
						check_coding_density_4 = append(check_coding_density_4, exons_inside_window_copy[exons_inside_window_end_out,]$genomic_coding_end == selected_window$upper_end)
					}

					#if we have exons with the start before the beginning of the window the end after the beginning of the window
					if(length(exons_inside_window_start_end_out)>0){

						##for those exons with the start before the window and the end after the window, we set the start coding region at the start of the window and the end of the coding region at the end of the window. As the exon occupy the whole window, all the window is coding
						exons_inside_window_copy[exons_inside_window_start_end_out,]$genomic_coding_start <- selected_window$lower_end
						exons_inside_window_copy[exons_inside_window_start_end_out,]$genomic_coding_end <- selected_window$upper_end
					
						#check
						check_coding_density_4 = append(check_coding_density_4, exons_inside_window_copy[exons_inside_window_start_end_out,]$genomic_coding_start == selected_window$lower_end)
						check_coding_density_4 = append(check_coding_density_4, exons_inside_window_copy[exons_inside_window_start_end_out,]$genomic_coding_end == selected_window$upper_end)
					}

					#summarize checks
					if(length(check_coding_density_4) > 0){ #if we have checks for the check_4 (i.e., some exons are in part outside and inside of the window)
					
						#if all checks are TRUE, then TRUE for the v4 check
						check_coding_density_4 = all(check_coding_density_4)
					} else {

						#save the checks as zero
						check_coding_density_4 = NA
					}

					#Now that we have applied filters to removed those areas outside the windows in exons that have part in part out of the window, we can check that we do not have any exon with start and/or end outside of the windows.
					check_coding_density_5 = !TRUE %in% c(exons_inside_window_copy$genomic_coding_start < selected_window$lower_end | exons_inside_window_copy$genomic_coding_end < selected_window$lower_end | exons_inside_window_copy$genomic_coding_start > selected_window$upper_end | exons_inside_window_copy$genomic_coding_end > selected_window$upper_end)


					## calculate the not overlapping ranges of coding sequences considering all transcripts
					#create a IRange object with the start and end of each of the exon sequences of the [i] gene
					#require(IRanges)
					exons_ranges = IRanges(start=exons_inside_window_copy$genomic_coding_start, end=exons_inside_window_copy$genomic_coding_end) #we can see the start and end of each exon sequence along with the width of each one.
			
					#check that the row number is ok
					test_all_ranges_included = length(exons_ranges) == nrow(exons_inside_window_copy)

					#check that the start of each exon in the IRange object is the same than in the original data.frame. Also check that the sum of start more width less 1 (the start point is already included) is equal to the end point in the original data frame. Also check the exons end less the exons starts plus 1 (because we want the length of the exons including both extremes) is equal to the with calculated in iranges.
					test_iranges = all(exons_ranges@start == exons_inside_window_copy$genomic_coding_start & (exons_ranges@start + exons_ranges@width - 1) == exons_inside_window_copy$genomic_coding_end & exons_ranges@width == (exons_inside_window_copy$genomic_coding_end - exons_inside_window_copy$genomic_coding_start + 1))

					#create a GRanges object with the ranges of all exon sequences of the [i] gene consindering the all the overlapping ranges
					gr = GRanges(seqnames = exons_inside_window_copy$chromosome_name, ranges = exons_ranges, strand = '*') #seqnames are the names of the chromosome names. This is very important, because if we select as seq names the exons ids, it consider each exon as independent and do not search for overlapping ranges within all exons; ranges are the start and end of each sequence, and are created with the function IRanges. I have check that when an exon occupy the whole window, if you use exon id as sequence name, the complete length of the range is not calculated, I have to use the chromosome name; strand indicate the sense of the sequence. We have the information of the strand in the strand variable, but as I have revised previously, genomic start/end have the same sense independently of the strand. Just in case, i will use *. In any case, I have seen no changes if this modified.
					overlap_sequences = reduce(gr) #‘reduce’ returns an object of the same type as ‘x’ containing reduced ranges for each distinct (seqname, strand) pairing. So you can calculate the overlapped ranges for each chromosome or strand.\

					#check that the start of the first range matches with the start of the first exon within the window. We also check that the end of the last range matches the end of the last exon

					#extract first the exon with the first coding region inside the window and the exon with the last coding region within the window
					start_first_exon = unique(exons_inside_window_copy[which(exons_inside_window_copy$genomic_coding_start == min(exons_inside_window_copy$genomic_coding_start)),]$genomic_coding_start)
					end_last_exon = unique(exons_inside_window_copy[which(exons_inside_window_copy$genomic_coding_end == max(exons_inside_window_copy$genomic_coding_end)),]$genomic_coding_end) #we use unique because we can have the same exon in different transcripts, and hence the same exon can be the first or the last one
				
					#make the test
					test_start_end = min(overlap_sequences[,]@ranges@start) == start_first_exon & max(overlap_sequences[,]@ranges@start + overlap_sequences[,]@ranges@width - 1) == end_last_exon #the end of each range is calculated in overlaped_sequences using the start and the width of each range (start + width subtracting 1 because the start is already included in width, so you have it two times)

					#additional checks
					#check that no exons is not outside of the not overlapped ranges
					#if we have more than 1 range
					if(!length(overlap_sequences@ranges) == 1){
				
						#check no exon has been left outside of the ranges, i.e., is not included between three extremes of the created ranges
						test_ranges_overlap = NULL
						for(k in 1:length(overlap_sequences@ranges)){

							#if [k] is NOT the last row
							if(!k==length(overlap_sequences@ranges)){

								#select the [k] row of the range data and the next one
								selected_row_1 = overlap_sequences[k,]@ranges
								selected_row_2 = overlap_sequences[k+1,]@ranges

								#test that no exon is excluded form the ranges
								result_test_overlap = c(
									#any exon start position is higher than the end of the [k] created range and lower than the start of the [k+1] created range?
									exons_inside_window_copy$genomic_coding_start > (selected_row_1@start + selected_row_1@width - 1) & exons_inside_window_copy$genomic_coding_start < selected_row_2@start,
									#any exon end position is higher than the end of the [k] created range and lower than the start of the [k+1] created range?
									exons_inside_window_copy$genomic_coding_end > (selected_row_1@start + selected_row_1@width - 1) & exons_inside_window_copy$genomic_coding_end < selected_row_2@start)
							} else { #if not and hence this is the last row

								#select the [k] row of the range data and the next one
								selected_row = overlap_sequences[k,]@ranges

								#test that no exon is excluded form the ranges
								result_test_overlap = c(
									#the start positions of exons are higher than the end of the last range
										exons_inside_window_copy$genomic_coding_start > (selected_row@start + selected_row@width - 1),
										#the end positions of exons are higher than the end of the last range
										exons_inside_window_copy$genomic_coding_end > (selected_row@start + selected_row@width - 1))
							}

							#are false? i.e., the start and end positions are not included in the regions between created ranges?
							result_test_overlap_final = result_test_overlap == FALSE

							#save the results
							test_ranges_overlap = append(test_ranges_overlap, result_test_overlap_final)
						}

						#if all the test have been made (for each range we have 2 tests of TRUE/FALSE for each exon)
						if(length(test_ranges_overlap) == (length(overlap_sequences@ranges) * nrow(exons_inside_window_copy) * 2)){

							#calculate if all are true
							test_ranges_overlap = all(test_ranges_overlap)
						} else {

							#if not NA
							test_ranges_overlap = NA
						}	
					} else { #if not and hence we only have 1 row, we check that all start and end exons are included within that unique range

						#select the unique created range we have of the range data and the next one
						selected_ranges = overlap_sequences[,]@ranges

						#test that no exon is excluded form the ranges
						test_ranges_overlap = c(
								#the start position of the unique coding exon is lower than the start of the unique created range OR higher than the end of that unique created range?
								exons_inside_window_copy$genomic_coding_start < selected_ranges@start | exons_inside_window_copy$genomic_coding_start > (selected_ranges@start + selected_ranges@width - 1),
								#the end position of the unique coding exon is lower than the start of the unique created range OR higher than the end of that unique created range?	
								exons_inside_window_copy$genomic_coding_end < selected_ranges@start | exons_inside_window_copy$genomic_coding_end > (selected_ranges@start + selected_ranges@width - 1))

						#are false? i.e., the start and end positions are not included in the regions outside the created range?
						test_ranges_overlap = test_ranges_overlap == FALSE

						#if all the test have been made (for each range we have 2 tests of TRUE/FALSE for each exon)
						if(length(test_ranges_overlap) == (length(overlap_sequences@ranges) * nrow(exons_inside_window_copy) * 2)){

							#calculate if all are true
							test_ranges_overlap = all(test_ranges_overlap)
						} else {

							#if not NA
							test_ranges_overlap = NA
						}
					}

					#now check that any of the not overlapped range is not overlapped with the rest
					if(!length(overlap_sequences@ranges) == 1){ #if we have more than one range
						#require(data.table)
						#for each range we make another test
						test_ranges_overlap_2_v1 = NULL
						for(k in 1:length(overlap_sequences)){

							#select the [k] range to be tested
							range_to_test = overlap_sequences[k,]@ranges

							#extract the start and end of range [k] to be tested
							start_range_to_test = range_to_test@start
							end_range_to_test = (range_to_test@start + range_to_test@width - 1) #we have to subtract 1 because stars is included in width, so you have the start two time, and you have to remove it one time the get the last point of the range

							#copy the overlap_sequences and remove the range to be tested
							overlap_sequences_without_tested_range = overlap_sequences[-k,]@ranges #these will be the range where we will check if the [k] range is included

							#extract the starts and ends of the ranges that are not the [k] range
							starts_to_compare = overlap_sequences_without_tested_range@start
							ends_to_compare = (overlap_sequences_without_tested_range@start + overlap_sequences_without_tested_range@width - 1)


							##we are using exactly the same approach to extract the genes/exons with part of their sequence inside each window. In this case we check if the sequence of each range is included in the sequence of the other ranges. If the ranges are not overlapped, we would expect that this is not the case.

							#check if the start of the range to test ([k] range) is included within the start and the end of any the other ranges (ranges to compare)
							start_within_ranges_to_compare = start_range_to_test >= starts_to_compare & start_range_to_test <= ends_to_compare

							#check if the end of the range to test ([k] range) is included within the start and the end of any the other ranges (ranges to compare)
							end_within_ranges_to_compare = end_range_to_test >= starts_to_compare & end_range_to_test <= ends_to_compare

							#check if the start of the range to test ([k] range) is before the start of any the other ranges (ranges to compare) and the end the that range to test is after the end of any of the ranges to compare
							start_end_both_sides_ranges_to_compare = start_range_to_test < starts_to_compare & end_range_to_test > ends_to_compare #here we are considering the possibility that the range to be tested [k] is very big and completely includes other ranges within it

								#this approach of comparing the start or end of one range with a vector of ranges works. Se for example this, we have a three ranges starting at 4, 5, and 6 respectively, while they end at 8, 9, 10. You can check if the following formula works: X >= c(4,5,6) & X <= c(4,5,6). 
									#3 >= c(4,5,6) & 3 <= c(8,9,10)
										#FALSE FALSE FALSE

									#4 >= c(4,5,6) & 4 <= c(8,9,10)
										#TRUE FALSE FALSE

									#5 >= c(4,5,6) & 5 <= c(8,9,10)
										#TRUE  TRUE FALSE
									
									#6 >= c(4,5,6) & 6 <= c(8,9,10)
										#TRUE TRUE TRUE

									#7 >= c(4,5,6) & 7 <= c(8,9,10)
										#TRUE TRUE TRUE

									#8 >= c(4,5,6) & 8 <= c(8,9,10)
										#TRUE TRUE TRUE

									#9 >= c(4,5,6) & 9 <= c(8,9,10)
										#FALSE  TRUE  TRUE

									#10 >= c(4,5,6) & 10 <= c(8,9,10)
										#FALSE FALSE  TRUE

									#11 >= c(4,5,6) & 11 <= c(8,9,10)
										#FALSE FALSE FALSE

								#You can see as 3 and 11 are false for all the ranges. 4 and 10 are true only for the for the first and last range respectively. 5 and 9 are TRUE for first-second and second-last ranges respectively. Finally, 6, 7, and 8 are TRUE for all ranges, because all these number are between 4 and 10. For example, all TRUE disappear when we move from the limit of the first range (8), so 9 is not included between 4 and 8 because is higher than 4 but not smaller than 8.

							#check that we don´t have any TRUE in the three checks, and save
							test_ranges_overlap_2_v1 = append(test_ranges_overlap_2_v1, !TRUE %in% start_within_ranges_to_compare & !TRUE %in% end_within_ranges_to_compare & !TRUE %in% start_end_both_sides_ranges_to_compare)
						}

						#save the check result if all the ranges were tested
						if(length(test_ranges_overlap_2_v1) == length(overlap_sequences)){
							test_ranges_overlap_2 = all(test_ranges_overlap_2_v1)
						} else { #if not save NA
							test_ranges_overlap_2 = NA
						}	
					} else { #if not and hence we have only one range

						#save the check as NA
						test_ranges_overlap_2 = NA
					}

					#sum the width of all non-overlapped ranges
					coding_sequence_length = sum(overlap_sequences@ranges@width)


					##check that the number of coding bases are the same being calculated with Genomic ranges
					#create the reference range using the window start and end
					window_range = IRanges(start=selected_window$lower_end, end=selected_window$upper_end) #create a IRange object with the start and end of the [k] window

					#convert to a GRanges object. We need a GRanges object to select those exons in the the subject GRange file that included in the reference range. 
					window_range_gr = GRanges(seqnames=unique(chromosome_name), ranges=window_range, strand = '*') #sequnames are the names of the chromosome names. This is very important, because if we select as seq names de exons ids, it consider each exon as independent and do not search for overlapping ranges within all exons; ranges are the start and end of each sequence, and are created with the function IRanges. I have checked that when an exon occupy the whole window, if you use exon id as sequence name, the complete length of the range is not calculated, I have to use the chromosome name. The same occurs when you try to get all the ranges without overlapping using disjoin, only are considered the ranges of the same seqname; strand indicate the sense of the sequence. We have the information of the strand in the strand variable, but as I have revised previously, genomic start/end have the same sense independently of the strand. Just in case, i will use *. In any case, I have seen no changes if this modified in the exon data (I have checked the no impact of strand in this exact example for gap length).

					#remove the rows without coding region
					subset_exon_data_chromosome_check_coding_length = subset_exon_data_chromosome[which( !is.na(subset_exon_data_chromosome$genomic_coding_start) | !is.na(subset_exon_data_chromosome$genomic_coding_end) ),]

					#select the gap ranges
					exon_ranges = IRanges(start=subset_exon_data_chromosome_check_coding_length$genomic_coding_start, end=subset_exon_data_chromosome_check_coding_length$genomic_coding_end) #create a IRange object with the start and end of [k] window. 

					#convert the IRange file into a genomic range file
					exon_ranges_gr = GRanges(seqnames=unique(chromosome_name), ranges=exon_ranges, strand = '*') #sequnames are the names of the chromosome names. This is very important, because if we select as seq names de exons ids, it consider each exon as independent and do not search for overlapping ranges within all exons; ranges are the start and end of each sequence, and are created with the function IRanges. I have checked that when an exon occupy the whole window, if you use exon id as sequence name, the complete length of the range is not calculated, I have to use the chromosome name. The same occurs when you try to get all the ranges without overlapping using disjoin, only are considered the ranges of the same seqname; strand indicate the sense of the sequence. We have the information of the strand in the strand variable, but as I have revised previously, genomic start/end have the same sense independently of the strand. Just in case, i will use *. In any case, I have seen no changes if this modified in the exon data (I have checked the no impact of strand in this exact example for gap length).
						#this explanation is taken from gene_coordinates_v8.r

					#calculate the not overlapping ranges
					not_overlapped_exon_ranges_gr = disjoin(x=exon_ranges_gr, with.revmap=TRUE) #‘disjoin’ returns an object of the same type as ‘x’ containing disjoint ranges for each distinct (seqname, strand) pairing. Split all the segments to have no overlap. If for example you have 1-10 and 5-7, the first range would be 1-4, then 5-7, and finally 8-10. You have the second range included within the first one. If ‘with.revmap=TRUE’, a metadata column that maps the output ranges to the input ranges is added to the returned object. This is basically a map, tells you what initial ranges are included in each new non-overlapped range.

					#check that the disjoined version of the gap ranges (without the revision map) is similar to the initial ranges. If true, that means that we have no overlapping in the gap ranges
					check_coding_density_6 = identical(exon_ranges_gr, disjoin(exon_ranges_gr)) #in this case we should have overlapping because several transcripts of the same and different genes can be overlapped.

					#find what of the tested ranges and are overlapped with the reference range
					hits_2 = findOverlaps(window_range_gr, not_overlapped_exon_ranges_gr)

					#calculate the exact overlap, i.e., the gap regions that included within the window. 
					overlaps_2 <- pintersect(window_range_gr[queryHits(hits_2)], not_overlapped_exon_ranges_gr[subjectHits(hits_2)])
						#queryHits extracts what of the reference ranges are overlapped with the tested ranges
						#subjectHits extracts what of the tested ranges are overlapped with the reference ranges. For example, the first tested range is not overlapped, so the first integer in the column of subjectHits in hits_2 is 2, not 1. 
						#You associate each reference range with the overlapped tested ranges. That is the input needed for pintersect.
						#the result is for each of the tested ranges overlapped with the reference ranges, the bases not overlapped are removed.
							#obtained form here "https://support.bioconductor.org/p/72656/"
					
					#calculate the sum of all not-overlapping coding regions inside the window				
					coding_sequence_length_2 = sum(overlaps_2@ranges@width)

					#check that new calculation of coding region length is similar to the previous one
					check_coding_density_7 = coding_sequence_length == coding_sequence_length_2
		

					## calculate the coding density for the [i] gene considering all the transcripts
					#calculate the exact length of the window. The length should be equal to selected length, but in cases when the window surpass the chromosome limit, the window is smaller. Therefore, we need to calculate the window length using the window coordinates. 
					exact_window_length = (selected_window$upper_end - selected_window$lower_end)+1

					#remove the gap length from the length of the window
					exact_window_length_final = exact_window_length - selected_gap

					#coding density, length of coding sequences divided by the total length of the window
					coding_density = coding_sequence_length/exact_window_length_final
				} else { #if we do not have exons inside the window, set all NA, except coding density that will be zero
					check_coding_density_1 = NA
					check_coding_density_2 = NA
					check_coding_density_4 = NA
					check_coding_density_5 = NA
					check_coding_density_6 = NA
					check_coding_density_7 = NA
					test_all_ranges_included = NA
					test_iranges = NA
					test_start_end = NA
					test_ranges_overlap = NA
					test_ranges_overlap_2 = NA
					coding_density = 0
				}
			} else {#if you have NA for the window limits

				#Set NA for everything, except selected window. We cannot set coding density as zero!! zero is a value, NA is no calculation.
				check_coding_density_1 = NA
				check_coding_density_2 = NA
				check_coding_density_4 = NA
				check_coding_density_5 = NA
				check_coding_density_6 = NA
				check_coding_density_7 = NA
				test_all_ranges_included = NA
				test_iranges = NA
				test_start_end = NA
				test_ranges_overlap = NA
				test_ranges_overlap_2 = NA
				coding_density = NA
			}

			#save the results in a data.frame
			coding_density_windows = rbind.data.frame(coding_density_windows, cbind.data.frame(selected_window, check_coding_density_1, check_coding_density_2, check_coding_density_4, check_coding_density_5, check_coding_density_6, check_coding_density_7, test_all_ranges_included, test_iranges, test_start_end, test_ranges_overlap, test_ranges_overlap_2, coding_density))			
		}
		#remove first row with NAs
		coding_density_windows = coding_density_windows[-1,] #I have checked for SCYL3 (ENSG00000000457) the first two windows. The first window (50kb) includes two genes (SCYL3 and C1orf112), whilst the second one also includes KIFAP3. I have check the map around SCYL3 (http://grch37.ensembl.org/Homo_sapiens/Location/View?db=core;g=ENSG00000000457;r=1:169817880-169864300), and i have seen two genes closer to SCYL3 than C1orf112, which are METTL18 and SELL. However, I have checked that the end of these genes (169680839 and 169764107) occur before the start of the two first windows (169816090.5 and 169791090.5). In contrast, C1orf112 starts very far away from SCYL3, but its end (169823221) reached the start of these windows. In the next window, which is wider and hence starts before (169741090.5), METTL18 is included. The next windows (500kb) already include SELE, SELP and SEL. Finally, the widest window (100 kb) also includes BLZF1, CCDC181, SLC19A2, F5, METTL11B. In that way, we have included all the coding genes you can see in the window. If you scroll to both sides, you can see as no more coding genes are present between teh boundaries of the last window (169341090.5 - 170341089.5). The rest are pseudogenes, RNa genes and processed transcripts.

		#save the number of genes per each window
		coding_density_50kb = rep(coding_density_windows[which(coding_density_windows$selected_length == 50000),]$coding_density, nrow(exon_data))		
		coding_density_100kb = rep(coding_density_windows[which(coding_density_windows$selected_length == 100000),]$coding_density, nrow(exon_data))		
		coding_density_200kb = rep(coding_density_windows[which(coding_density_windows$selected_length == 200000),]$coding_density, nrow(exon_data))		
		coding_density_500kb = rep(coding_density_windows[which(coding_density_windows$selected_length == 500000),]$coding_density, nrow(exon_data))		
		coding_density_1000kb = rep(coding_density_windows[which(coding_density_windows$selected_length == 1000000),]$coding_density, nrow(exon_data))		


		##summarize all the coding_checks
		#create a vector with the check to be summarized
		coding_checks_to_summarize = c("check_coding_density_1","check_coding_density_2","check_coding_density_4","check_coding_density_5","check_coding_density_6","check_coding_density_7","test_all_ranges_included","test_iranges","test_start_end","test_ranges_overlap","test_ranges_overlap_2")

		#for each check to be summarized
		for(j in 1:length(coding_checks_to_summarize)){

			#select the [j] check to summarize
			selected_coding_check = coding_checks_to_summarize[j]

			#extract the corresponding column
			selected_column_coding_check = coding_density_windows[,which(colnames(coding_density_windows) == selected_coding_check)]	
			#if no FALSE is present in the check
			if(!FALSE %in% selected_column_coding_check){

				#if there is no FALSE in is.na() and hence all cases are NA
				if(!FALSE %in% is.na(selected_column_coding_check)){

					#set the check as TRUE
					summary_coding_check = rep(NA, nrow(exon_data))
				} else { #if not, and hence not all cases are NA
					
					#if you have NAs and TRUEs
					if(TRUE %in% is.na(selected_column_coding_check) & TRUE %in% selected_column_coding_check){
						
						#set the check as TRUE/NA
						summary_coding_check = rep("TRUE/NA", nrow(exon_data))
					} else { #if not, we dot not have any NA

						#set the check as TRUE
						summary_coding_check = rep(TRUE, nrow(exon_data))
					}
				}
			} else { #if we have FALSE

				summary_coding_check = rep(FALSE, nrow(exon_data))
			}

			#assign the value of the summary check to the corresponding variable.
			assign(selected_coding_check, summary_coding_check) #see second response in "https://stackoverflow.com/questions/28909191/treat-string-as-object-name-in-a-loop-in-r" for further details about assign		
		}


		#reorder data of the [i] gene from the gene list to get gene name (hgnc_symbol) and check that chromosome name and positions are correct 
		#reorder rows following exon_data again. We reorder rows of exon data following start_end_coding_regions
		gene_characteristics_ordered = gene_characteristics[match(paste(exon_data$ensembl_transcript_id, exon_data$ensembl_exon_id), paste(gene_characteristics$ensembl_transcript_id, gene_characteristics$ensembl_exon_id)),] #we match using both exon id and transcript id because the same exon id can be in different transcripts, thus we need two conditions for matching. The paste function create strings using the transcript id and the exon id, you can create these strings using start_end_coding_regions and exon_data, then use match to match the rows of exon data to those of start_end_coding_regions. See 'https://stackoverflow.com/questions/47404477/match-with-multiple-criteria-without-loop-in-r' for further details.

		#check that the first and the last exons (and the rest of them) are the same in gene list and exon data. I cannot compare start position because the position in gene list (all_genes_grch37_exon_filter_final) is calculate considering all exons, coding and non coding. we are only using coding exons. Also check that the chromosome name is ok. Also check that all rows have data for cds
		test_position_gene_exons = gene_characteristics_ordered$ensembl_exon_id == exon_data$ensembl_exon_id
		test_chr_name = unique(gene_characteristics_ordered$chromosome_name) == selected_chr
		test_na_cds = all(!is.na(exon_data$cds_length))

		#bind results in a row of dataframe
		binding_results = cbind.data.frame(chromosome_name, hgnc_symbol, gene_id, test_rows_initial_datasets_1, test_rows_initial_datasets_2, test_gene_id, gene_biotype, transcript_id, transcript_biotype, exon_id, test_gene_transcripts_biotype, gene_start, gene_end, gene_length, middle_point, test_gene_length_center, windows_check_1, windows_check_2, windows_check_3, windows_check_4, windows_check_5, lower_end_window_50kb, upper_end_window_50kb, lower_end_window_100kb, upper_end_window_100kb, lower_end_window_200kb, upper_end_window_200kb, lower_end_window_500kb, upper_end_window_500kb, lower_end_window_1000kb, upper_end_window_1000kb, n_genes_50kb, n_genes_100kb, n_genes_200kb, n_genes_500kb, n_genes_1000kb, check_n_genes_0, check_n_genes_1, check_n_genes_2, check_n_genes_3, check_n_genes_4, check_coding_density_1, check_coding_density_2, check_coding_density_4, check_coding_density_5, check_coding_density_6, check_coding_density_7, test_all_ranges_included, test_iranges, test_start_end, test_ranges_overlap, test_ranges_overlap_2, coding_density_50kb, coding_density_100kb, coding_density_200kb, coding_density_500kb, coding_density_1000kb, test_position_gene_exons, test_chr_name, test_na_cds)

		#check that we have the same number of rows than in exon data
		if(!nrow(binding_results) == nrow(exon_data)){

			#print the error
			print('ERROR! ROW NUMBER NOT MATCHES')

			#break the loop
			break			
		}

		#save the results
		final_positions = rbind.data.frame(final_positions, binding_results)
	}
	
	#remove NA row. We select those rows for which the sum of NAs is equal to the number of columns.
	final_positions = final_positions[-which( rowSums(is.na(final_positions)) == ncol(final_positions) ),]

	#return the final dataset
	return(final_positions)
}

##Parallelize the process
require(foreach)
require(doParallel) #for parallel

#write the list of chromosomes
list_chromosomes = c(1:22)

# set up cluster
clust <- makeCluster(7) 
registerDoParallel(clust)

#run the function
final_positions = foreach(i = list_chromosomes, .packages=c("GenomicRanges"), .combine="rbind") %dopar% { #we load genomic ranges for the overlapping ranges of coding sequences
    genomic_coords_coding_density(selected_chr = i)
} 

#stop the cluster 
stopCluster(clust)



################################
########## IMPORTANT ###########
################################

#the windows lengths were calculated using the middle points without removing the decimals, this having them also decimals. I make all the corresponding checks, and the I removed the decimals of upper and lower limits of the windows. These are the ends saved (without decimals) and used for calculating gene number and coding density. 



########################################
########## CHECK THE RESULTS ###########
########################################

#check head and tails
head(final_positions)
tail(final_positions)

#look for NAs or FALSE in the checks
summary(final_positions) #NO FALSES.Exceptions:
	#NAs in check_n_genes_1. 
	#FALSE check_coding_density_6.

#check check_n_genes_1.
summary(final_positions$check_n_genes_1) 
unique(final_positions$check_n_genes_1) #We have TRUE, TRUE/NA and NA. For this check we avoid doing it when some genes had not hgnc symbol, so you cannot calculate the number of genes using this variable
final_positions[which(is.na(final_positions$check_n_genes_1)),]$hgnc_symbol #there are cases with hgnc symbl. The gene at the center can have hgnc symbol, but any of the genes included in the window not, and then the test fail. In addition, there are NA for those windows with NA for coordinates (see below).

#check_coding_density_6
summary(final_positions$check_coding_density_6) #here we checked the overlap between coding exons inside a window. TRUE means that no overlap exist. We can have FALSE, because different transcript of the same gene can share an exon. In addition, different genes can overlap in their coding regions. Indeed all cases are NA (from NA windows, i.e., no coordinate) or FALSE (overlap within the gene).


##DIFFERENCES RESPECT TO V9

##NAs caused by removed windows because they surpass the chromosome limit. these NAs are new in v10
#IMPORTANT: You have thousands of NA ins the coordinates of big windows. This does no mean that there are thousand of genes without that window, because final_positions has a rows for EACH EXON! Therefore, we have removed thousand of exons when removing windows that surpass the chromosome limit, not genes. The real number of genes implicated can be obtained from the dataset after the duplicates have been removed.  

#In check_n_genes_1 and other checks we can have NAs because of the removed windows
#remove duplicates to do some checks. We need to have only one row per gene, all the rows of a gene should have the same values
final_positions_no_dupli = final_positions[-which(duplicated(final_positions$gene_id)),]
#check
length(unique(final_positions$gene_id)) == nrow(final_positions_no_dupli)

#check that the genes with NA for the coordinate of one end of a window, are the same than those with NA for the coordinate of the other extreme of that window 
summary(final_positions_no_dupli[which(is.na(final_positions_no_dupli$upper_end_window_50kb)),]$gene_id == final_positions_no_dupli[which(is.na(final_positions_no_dupli$lower_end_window_50kb)),]$gene_id)
summary(final_positions_no_dupli[which(is.na(final_positions_no_dupli$upper_end_window_100kb)),]$gene_id == final_positions_no_dupli[which(is.na(final_positions_no_dupli$lower_end_window_100kb)),]$gene_id)
summary(final_positions_no_dupli[which(is.na(final_positions_no_dupli$upper_end_window_200kb)),]$gene_id == final_positions_no_dupli[which(is.na(final_positions_no_dupli$lower_end_window_200kb)),]$gene_id)
summary(final_positions_no_dupli[which(is.na(final_positions_no_dupli$upper_end_window_500kb)),]$gene_id == final_positions_no_dupli[which(is.na(final_positions_no_dupli$lower_end_window_500kb)),]$gene_id)
summary(final_positions_no_dupli[which(is.na(final_positions_no_dupli$upper_end_window_1000kb)),]$gene_id == final_positions_no_dupli[which(is.na(final_positions_no_dupli$lower_end_window_1000kb)),]$gene_id)

#extract the genes with at least one removed windows
genes_with_removed_windows = final_positions_no_dupli[which(is.na(final_positions_no_dupli$lower_end_window_50kb) | is.na(final_positions_no_dupli$lower_end_window_100kb) | is.na(final_positions_no_dupli$lower_end_window_200kb) | is.na(final_positions_no_dupli$lower_end_window_500kb) | is.na(final_positions_no_dupli$lower_end_window_1000kb)),] #which rows have NA for the coordinate of any of the windows? We use only the lower end. If one end has NA, the other will have NA (this was revised in the previous check).
#check that these genes are all included in those without coordinate for the 1000kb window
summary(final_positions_no_dupli[which(is.na(final_positions_no_dupli$lower_end_window_1000kb)),]$gene_id == genes_with_removed_windows$gene_id) #If 6 50kb windows are removed, then for the 100kb windows, you will have these 6 windows and new ones removed. If the 50 kb window surpass the chromosome limit, obviously the 100kb windows of these genes will also surpass the chromosome limits. Each size category includes all the previous genes. Finally, the 1000kb window size includes ALL the previous cases and some new ones. Because of this, the genes without 1000kb window are equal to the genes without at least one window.  
#see the number of cases. This is the total number of genes that suffered losses:
nrow(genes_with_removed_windows) #293 genes
#extract the total number of windows removed
length(which(is.na(final_positions_no_dupli$lower_end_window_50kb))) + length(which(is.na(final_positions_no_dupli$lower_end_window_100kb))) + length(which(is.na(final_positions_no_dupli$lower_end_window_200kb))) + length(which(is.na(final_positions_no_dupli$lower_end_window_500kb))) + length(which(is.na(final_positions_no_dupli$lower_end_window_1000kb))) #443 windows
	#There is 1 gene for which 50b windows have been removed. 6 in the case of 100kb windows, 22 for 200kb, 121 for 500kb and 293 for 1000kb. 
	 	#Therefore, 443 windows from 283 genes have been removed.  

#select those genes for which there is NA in the gene number of at least one window 
genes_with_na_gene_number = final_positions_no_dupli[which(is.na(final_positions_no_dupli$n_genes_50kb) | is.na(final_positions_no_dupli$n_genes_100kb) | is.na(final_positions_no_dupli$n_genes_200kb) | is.na(final_positions_no_dupli$n_genes_500kb) | is.na(final_positions_no_dupli$n_genes_1000kb)),]

#check if genes with at least one NA for gene coordinate are the same than those with at least one NA per gene number
summary(genes_with_removed_windows$gene_id == genes_with_na_gene_number$gene_id)

#check that all checks from gene number calculations that have NA are those with NA in windows coordinates
summary(final_positions_no_dupli[which(final_positions_no_dupli$check_n_genes_0 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$check_n_genes_1 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id) #this check can have NA because of empty hgnc symbol. Therefore we can have different genes.
summary(final_positions_no_dupli[which(final_positions_no_dupli$check_n_genes_2 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$check_n_genes_3 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$check_n_genes_4 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)

#calculate the number of genes for which there is NA in the coding density of at least one window 
genes_with_na_coding_density = final_positions_no_dupli[which(is.na(final_positions_no_dupli$coding_density_50kb) | is.na(final_positions_no_dupli$coding_density_100kb) | is.na(final_positions_no_dupli$coding_density_200kb) | is.na(final_positions_no_dupli$coding_density_500kb) | is.na(final_positions_no_dupli$coding_density_1000kb)),]

#check if genes with at least one NA for gene coordinate and at least one NA per gene number
summary(genes_with_removed_windows$gene_id == genes_with_na_coding_density$gene_id)

#check that all the cases with NA for coding density are those genes with NA for at least one window. WARNING: This can have have false without problem! See below.
summary(final_positions_no_dupli[which(final_positions_no_dupli$check_coding_density_1 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$check_coding_density_2 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$check_coding_density_4 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$check_coding_density_5 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$check_coding_density_6 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$check_coding_density_7 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$test_all_ranges_included %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$test_iranges %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$test_start_end %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$test_ranges_overlap %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
summary(final_positions_no_dupli[which(final_positions_no_dupli$test_ranges_overlap_2 %in% c(NA, "TRUE/NA")),]$gene_id == genes_with_removed_windows$gene_id)
	#coding_check_6 can give FALSE, because FALSE in this check is common. We are checking different coding regions within a gene are overlapped. This is very common, because you can have several transcripts in a gene. In general, if we find only one FALSE, everything is set as FALSE. This is like a red flag in general in the script, although in this cases is not very relevant.
	#In the case of check_coding_density_1, check_coding_density_2, check_coding_density_4, check_coding_density_5, check_coding_density_6, check_coding_density_7, test_all_ranges_included, test_iranges, test_start_end, test_ranges_overlap, test_ranges_overlap_2 you can obtain FALSE because you can have NAs if no coding region is included in the region.

#NOTE: The windows_check_5 does not have NAs. This was the first check after removing the windows that surpass the chromosome limit, but I simply check that no FALSE was present and hence no window surpass the limit. Therefore, the TRUEs includes windows with coordinate that do not surpass, and windows with NA in the coordinate. For the rest of check that were calculated for each window, we set NA if the windows have no coordinate. 


## DIFFERENCES RESPECT TO V8.
#There differences in the median start/end of the genes analyzed, the median gene length, median number of genes inside each windows size. This can be explained because we removed the whole chromosome X respect to version 8th. Therefore, the set of genes analyzed are different. The removal of the whole chromosome, and its genes affects the median number of genes you can find inside each window size. Similarly, the median length of the genes will different, because you have reduced your set of genes!! 
	
#There are also differences in the positions of the windows. We have removes windows that surpass the limits of the chromosome. Windows reaching the start of the chromosome (i.e., negative coordinates) and end of the chromosome. Indeed, you can see in the summary of the v8 that the min value for the lower end of all windows is negative!! That does not make any sense! This problem has been solved in the new version. The windows_check_5 check that no lower limit is < 1 and no upper limit is bigger than the corresponding chromosome length. We have all TRUE for this check.
#the minimum coordinate of all widows is equal or higher than 1
min(na.omit(final_positions$lower_end_window_50kb)) >= 1
min(na.omit(final_positions$lower_end_window_100kb)) >= 1
min(na.omit(final_positions$lower_end_window_200kb)) >= 1
min(na.omit(final_positions$lower_end_window_500kb)) >= 1
min(na.omit(final_positions$lower_end_window_1000kb)) >= 1 #we removed the NA for the windows that have been removed because of this problem of surpassing the chromosome limit.
#the maximum coordinate of all widows is equal or lower than the maximum chromosome length 
max(na.omit(final_positions$upper_end_window_50kb)) <= max(chrom_length_ucsc_hg19$length_bp)
max(na.omit(final_positions$upper_end_window_100kb)) <= max(chrom_length_ucsc_hg19$length_bp)
max(na.omit(final_positions$upper_end_window_200kb)) <= max(chrom_length_ucsc_hg19$length_bp)
max(na.omit(final_positions$upper_end_window_500kb)) <= max(chrom_length_ucsc_hg19$length_bp)
max(na.omit(final_positions$upper_end_window_1000kb)) <= max(chrom_length_ucsc_hg19$length_bp) #we removed the NA for the windows that have been removed because of this problem of surpassing the chromosome limit.

#in the case of coding density, we also made a change in the size of the window that affects. We removed the size corresponding with gaps inside the window. Therefore, the length of coding regions is divided by the length of the windows - gap length. 
 
 
#check that all exons included in final_positions are in full_exon_data_filtered_final. We have to calculate the intersection between transcript id and exon id, because exons from different transcripts can have the same exon id
summary(paste(final_positions$transcript_id, final_positions$exon_id) %in% paste(full_exon_data_filtered_final$ensembl_transcript_id, full_exon_data_filtered_final$ensembl_exon_id))
#the same for all_genes_grch37_exon_filter_final
summary(paste(final_positions$transcript_id, final_positions$exon_id) %in% paste(all_genes_grch37_exon_filter_final$ensembl_transcript_id, all_genes_grch37_exon_filter_final$ensembl_exon_id)) 
	#we did not do it in the inverse way (check if all exons of the input data are in the output) because the function removes those non-coding exons. 

#check that all genes per chromosome were included
#calculate the number of genes per chromosome
number_genes_per_chromosome = NA
for(i in 1:length(list_chromosomes)){ #for each chromosome

	#select the [i] chromosome
	selected_chromosome = list_chromosomes[i]

	#select those rows of the [i] chromosome in all_genes_grch37_exon_filter_final and extract the unique cases of gene id (the unique gene ids)
	chromosome_subset = unique(all_genes_grch37_exon_filter_final[which(all_genes_grch37_exon_filter_final$chromosome_name == selected_chromosome),]$ensembl_gene_id)

	#save the length of unique genes
	number_genes_per_chromosome = append(number_genes_per_chromosome, length(chromosome_subset))
}
#remove the first element of the vector, which is a NA
number_genes_per_chromosome = number_genes_per_chromosome[-1]

#calculate the total number of genes
total_number_genes = sum(number_genes_per_chromosome) 
#check this number is equal to the length of unique genes
length(unique(all_genes_grch37_exon_filter_final$ensembl_gene_id)) == total_number_genes

#check that you number of unique genes is equal to the real number of genes
length(unique(final_positions$gene_id)) == total_number_genes

#check that you number of unique exons is equal to the real number of exons
length(unique(final_positions$ensembl_exon_id)) == length(unique(all_genes_grch37_exon_filter_final[which(!is.na(all_genes_grch37_exon_filter_final$genomic_coding_start) & !is.na(all_genes_grch37_exon_filter_final$genomic_coding_end)),]$ensembl_exon_id))#we have to remove all exons without cds data of all_genes_grch37_exon_filter_final, because these were removed from final_positions 


##IMPORTANT: In gene coordinates, we do still have the three cases with window coordinated but completely overlapped with a gap indicated as coding density as zero, not NA. gene_coordinates has to be used only for window coordinates.
#save final_positions
write.table(final_positions, '/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/gene_number_cds_coords.txt', sep='\t', row.names=FALSE)

#load the data to check that the writing worked ok
final_positions_2 = read.table('/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/gene_number_cds_coords.txt', sep='\t', header=TRUE)

#make the test
test=NULL
for(i in 1:ncol(final_positions)){ #for each column of the final positions

	#select that column in final_positions and final_positions_2
	selected_column_final_positions = final_positions[,i]
	selected_column_test = final_positions_2[,i]

	#if any of the selected columns has no NA
	if(all(!is.na(selected_column_final_positions)) & all(!is.na(selected_column_test))){

		#if the column is numeric we have to round to get exactly the same numbers
		if(is.numeric(selected_column_final_positions) & is.numeric(selected_column_test)){

			#round and check that all numbers are equal
			test = append(test, all(round(selected_column_final_positions) == round(selected_column_test)))
		} else { #if not, and hence we don´t have numeric data

			#make the test without doing anything else
			test = append(test, all(selected_column_final_positions == selected_column_test))
		}
	} else { #if not and hence we have NAs, we apply na.omit

		#if the column is numeric we have to round to get exactly the same numbers
		if(is.numeric(selected_column_final_positions) & is.numeric(selected_column_test)){

			#round and check that all numbers are equal
			test = append(test, all(round(na.omit(selected_column_final_positions)) == round(na.omit(selected_column_test))))
		} else { #if not, and hence we don´t have numeric data

			#make the test without rounding
			test = append(test, all(na.omit(selected_column_final_positions) == na.omit(selected_column_test)))
		}
	}
}
all(test)#all TRUE



####################################################
######## PREPARE THE FINAL FILES FOR DAVID #########
####################################################

##remove the duplicates
#remove those windows that are duplicated in gene_id. We are using the same code used in the other confounding factors to remove duplicated. It is tested. 
final_positions_no_duplicates = final_positions[-which(duplicated(final_positions$gene_id)),]
#check we have the correct number of rows
nrow(final_positions_no_duplicates) == length(unique(final_positions$gene_id))
#check we have the correct gene_ids
summary(final_positions_no_duplicates$gene_id == unique(final_positions$gene_id))


## gene length data
#select the gene_ids and the gene length
final_gene_length = final_positions_no_duplicates[,c("gene_id", "gene_length")]

#check we have the correct number of rows
nrow(final_gene_length) == length(unique(final_positions$gene_id))
#check we have the correct gene_ids
summary(final_gene_length$gene_id == unique(final_positions$gene_id))

#take a look
str(final_gene_length)
head(final_gene_length)
summary(final_gene_length)
	#the median and mean are 25811.00 and 65677.91.
	#No NA because in this case the windows surpassing the chromosome limit are not a problem. We are using the gene length according to ensemble, so the genes should not surpass the chromosome limit. In addition, if there are gaps inside the gene it is not a problem, we know where the gene starts and ends, that is the point here. 
	#According to wikipedia (https://en.wikipedia.org/wiki/Human_genome), the median size of a protein-coding gene is 26,288 bp (mean = 66,577 bp). In our case, we have a median value of 25,811.00 and a mean of 65,677.91. Values are very close. 

#check that maximum gene end in each chromosome is always lower than the chromosome length
check_gene_length = NULL
#for each chromosome
for(i in 1:length(unique(final_positions_no_duplicates$chromosome_name))){

	#select the [i] chromosome
	selected_chromosome = unique(final_positions_no_duplicates$chromosome_name)[i]
	
	#subset final_positions_no_duplicates and chrom_length_ucsc_hg19
	subset_final_gene_length = final_positions_no_duplicates[which(final_positions_no_duplicates$chromosome_name == selected_chromosome),]
	subset_chrom_length_ucsc_hg19 = chrom_length_ucsc_hg19[which(chrom_length_ucsc_hg19$chromosome == paste("chr", selected_chromosome, sep="")),]

	#save the check
	check_gene_length = append(check_gene_length, max(subset_final_gene_length$gene_end) < subset_chrom_length_ucsc_hg19$length_bp)
}
#take a look
summary(check_gene_length) #ALL TRUE, no gene end is bigger than the chromosome limit. 

#check that all gene start are higher than zero
min(final_positions_no_duplicates$gene_start) > 0 #Starts are higher than zero and ends are lower than the length of the corresponding chromosome.


## gene number data
# extract gene id and the number of gene inside each window
final_gene_number = final_positions_no_duplicates[,c("gene_id", "n_genes_50kb", "n_genes_100kb", "n_genes_200kb", "n_genes_500kb", "n_genes_1000kb")]

#check we have the correct number of rows
nrow(final_gene_number) == length(unique(final_positions$gene_id))
#check we have the correct gene_ids
summary(final_gene_number$gene_id == unique(final_positions$gene_id))

#take a look
str(final_gene_number)
head(final_gene_number)
summary(final_gene_number) 
	#NAs: There is 1 gene for which 50b windows have been removed. 6 in the case of 100kb windows, 22 for 200kb, 121 for 500kb and 293 for 1000kb. These are the cases removed because of the window surpass the chromosome limit.
	#The mean and median number of genes is increasing from 50kb windows to 1000kb windows.
	#The minimum is 1 and the maximum is 70, which sounds good.

#check that the rows with NA in gene number are the same than those with NA for any window coordinate in each window size
summary(which(is.na(final_gene_number$n_genes_50kb)) == which(is.na(final_positions_no_duplicates$lower_end_window_50kb) | is.na(final_positions_no_duplicates$upper_end_window_50kb)))
summary(which(is.na(final_gene_number$n_genes_100kb)) == which(is.na(final_positions_no_duplicates$lower_end_window_100kb) | is.na(final_positions_no_duplicates$upper_end_window_100kb)))
summary(which(is.na(final_gene_number$n_genes_200kb)) == which(is.na(final_positions_no_duplicates$lower_end_window_200kb) | is.na(final_positions_no_duplicates$upper_end_window_200kb)))
summary(which(is.na(final_gene_number$n_genes_500kb)) == which(is.na(final_positions_no_duplicates$lower_end_window_500kb) | is.na(final_positions_no_duplicates$upper_end_window_500kb)))
summary(which(is.na(final_gene_number$n_genes_1000kb)) == which(is.na(final_positions_no_duplicates$lower_end_window_1000kb) | is.na(final_positions_no_duplicates$upper_end_window_1000kb)))

#load tbfs data to extract those rows with window coordinates but not tbfs data because the window is completely overlapped with a gap
tbfs_data = read.table('/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/tbfs_density_raw_v3.txt', sep='\t', header=TRUE)

#from final_gene_number, select those rows with a gene_id that is included within the gene_id of the rows in final_tbfs that have window coordinates but the final window has a length of zero.
final_gene_number[which(final_gene_number$gene_id %in% tbfs_data[which(!is.na(tbfs_data$selected_lower_window) & !is.na(tbfs_data$selected_upper_window) & tbfs_data$window_length_no_gaps == 0),]$gene_id),]
	#The three cases with window coordinates but that the window is completely overlapped with a gap have a gene number of 1, which makes sense. We are counting the gene in the middle. 

	#I have checked that these 50kb windows are overlapped with only one gene
		#http://grch37.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000148357;r=9:133046882-133309510
		#http://grch37.ensembl.org/Homo_sapiens/Location/View?db=core;g=ENSG00000168280;r=2:149733046-149783045
		#http://grch37.ensembl.org/Homo_sapiens/Location/View?db=core;g=ENSG00000185974;r=13:114356089-114406088


## coding density data
# extract gene id and the coding density inside each window
final_coding_density = final_positions_no_duplicates[,c("gene_id", "coding_density_50kb", "coding_density_100kb", "coding_density_200kb", "coding_density_500kb", "coding_density_1000kb")]

#check we have the correct number of rows
nrow(final_coding_density) == length(unique(final_positions$gene_id))
#check we have the correct gene_ids
summary(final_coding_density$gene_id == unique(final_positions$gene_id))

#take a look
str(final_coding_density)
head(final_coding_density)
summary(final_coding_density)
	#NAs: There is 1 gene for which 50b windows have been removed. 6 in the case of 100kb windows, 22 for 200kb, 121 for 500kb and 293 for 1000kb. These are the cases removed because of the window surpass the chromosome limit.
	#The mean and median coding density is decreasing from 50kb windows to 1000kb windows. Bigger windows have more bases, therefore the coding bases have to be a lot of more to reach the similar density than smaller windows.
	#The minimum is zero and the maximum is 0.38, which sounds good.

#check that the rows with NA in gene number are the same than those with NA for any window coordinate in each window size
summary(which(is.na(final_coding_density$coding_density_50kb)) == which(is.na(final_positions_no_duplicates$lower_end_window_50kb) | is.na(final_positions_no_duplicates$upper_end_window_50kb)))
summary(which(is.na(final_coding_density$coding_density_100kb)) == which(is.na(final_positions_no_duplicates$lower_end_window_100kb) | is.na(final_positions_no_duplicates$upper_end_window_100kb)))
summary(which(is.na(final_coding_density$coding_density_200kb)) == which(is.na(final_positions_no_duplicates$lower_end_window_200kb) | is.na(final_positions_no_duplicates$upper_end_window_200kb)))
summary(which(is.na(final_coding_density$coding_density_500kb)) == which(is.na(final_positions_no_duplicates$lower_end_window_500kb) | is.na(final_positions_no_duplicates$upper_end_window_500kb)))
summary(which(is.na(final_coding_density$coding_density_1000kb)) == which(is.na(final_positions_no_duplicates$lower_end_window_1000kb) | is.na(final_positions_no_duplicates$upper_end_window_1000kb)))

#load tbfs data to extract those rows with window coordinates but not tbfs data because the window is completely overlapped with a gap
tbfs_data = read.table('/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/tbfs_density_raw_v3.txt', sep='\t', header=TRUE)

#from coding density, select those rows with a gene_id that is included within the gene_id of the rows in final_tbfs that have window coordinates but the final window has a length of zero.
final_coding_density[which(final_coding_density$gene_id %in% tbfs_data[which(!is.na(tbfs_data$selected_lower_window) & !is.na(tbfs_data$selected_upper_window) & tbfs_data$window_length_no_gaps == 0),]$gene_id),]
	#coding_density_50kb is zero, but it should be NA. If the window is completely overlapped with a gap, we have no data about coding density inside the window, so we cannot calculate coding density, is NA, NOT zero. 

#set it as NA
final_coding_density[which(final_coding_density$gene_id %in% tbfs_data[which(!is.na(tbfs_data$selected_lower_window) & !is.na(tbfs_data$selected_upper_window) & tbfs_data$window_length_no_gaps == 0),]$gene_id),]$coding_density_50kb <- NA
	#note that the in the original gene_coordinate file, these three rows have zero in coding density but I set them as zero in the new versions.
#check
final_coding_density[which(final_coding_density$gene_id %in% tbfs_data[which(!is.na(tbfs_data$selected_lower_window) & !is.na(tbfs_data$selected_upper_window) & tbfs_data$window_length_no_gaps == 0),]$gene_id),]

#merge the data not duplicated and the gaps data to check that we are selecting the problematic genes
merged_data = merge(final_positions_no_duplicates, gap_results_extracted_final, by="gene_id")

#take those cases in which the window length of the 50kb window less the gap length is only zero
merged_data[which((merged_data$upper_end_window_50kb - merged_data$lower_end_window_50kb + 1) - merged_data$length_gaps_50kb == 0),]
	#These are the same cases and in gene_coordinates, these are coding_density_50kb equal to zero. The NA were only added to final_coding_density

#summary
summary(final_coding_density) #Now have three more NAs in coding_density_50kb. 


##save the files

#IMPORTANT: In gene coordinates, we do still have the three cases with window coordinated but completely overlapped with a gap indicated as coding density as zero, not NA. gene_coordinates has to be used only for window coordinates.

#save gene length
write.table(final_gene_length, '/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/gene_length_v1.txt', sep='\t', row.names=FALSE)

#save gene length
write.table(final_gene_number, '/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/gene_number_v1.txt', sep='\t', row.names=FALSE)

#save gene length
write.table(final_coding_density, '/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/coding_density_v1.txt', sep='\t', row.names=FALSE)



#####################################
######## SAVE THE WORKSPACE #########
#####################################
save.image('/media/dftortosa/Windows/Users/dftor/Documents/diego_docs/science/postdoc_enard_lab/projects/method_deep/data/search_diego/results/rdata/gene_coordinates_v10.RData')
library(biomaRt)
library(GenomicRanges)
library(data.table)
library(dplyr)
require(stringr)
require(D3GB)